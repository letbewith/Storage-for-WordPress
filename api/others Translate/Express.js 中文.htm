<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"><script src="Express.js%20%E4%B8%AD%E6%96%87_files/ga.js" async="" type="text/javascript"></script><script src="Express.js%20%E4%B8%AD%E6%96%87_files/sea.js" id="seajsnode"></script><meta charset="utf-8"><title>&lt;贴板&gt; Express.js 中文入门指引手册 - CSSer</title><meta name="description" content="Express.js 中文入门指引手册   Express   是基于   Node.js  ，高性能、一流的web开发框架。      本手册由一回于 2011-4-24 首次翻译，如今已经过去接近一年，express 最新的版本已经与当时翻译有些脱节，为了方便内容更新，将使用 csser 开发的贴板功能进行维护，也方便大家针对细节进行讨论，并请指出翻译不当之处。   "><link rel="stylesheet" href="Express.js%20%E4%B8%AD%E6%96%87_files/csser.css"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><link rel="shortcut icon" type="image/x-icon" href="http://s0.csser.com/favicon.ico"><link rel="alternate" type="application/rss+xml" title="CSSer" href="http://www.csser.com/feed"><script>var VERSION = 'v0.5.1-3', BASE_URL = 'http://www.csser.com',STATIC_URL = 'http://s0.csser.com',S1_URL = 'http://s1.csser.com',DEBUG = 0,CSRF = 'Jndw00ARDdpETpVnePRX4qtP',UID = '',USERNAME = '',DOMAIN = '', AVATAR = '', EMAIL='', SOCKET_PORT = 3000,SKEY = 'TiMtndgI8xXLrmZn4bvIeuhQ.eiLj5ui9+oMfzBxBaoFjeVc7MqMjryPlDcWUCgxZ1nA';</script><link rel="stylesheet" href="Express.js%20%E4%B8%AD%E6%96%87_files/default.css"><link rel="stylesheet" href="Express.js%20%E4%B8%AD%E6%96%87_files/simple.css"></head><body><div class="navbar navbar-fixed-top"><div class="navbar-inner"><div class="container"><a href="http://www.csser.com/" title="csser 前端技术社区" class="brand"><img src="Express.js%20%E4%B8%AD%E6%96%87_files/logo.png" alt="csser 前端技术社区" height="20" width="119"></a><div class="nav-collapse"><form id="search" method="get" action="http://www.google.com/search" target="_blank" class="nav-search pull-left"><div class="btn-group input-append"><input name="q" autocomplete="off" placeholder="搜索" class="search-query span2" type="text"><button type="submit" class="btn"><i class="icon-search"></i></button></div><input name="newwindow" value="1" type="hidden"></form><ul class="nav nav-main"><li><a href="http://www.csser.com/">首页</a></li><li class="pop-tags"><a href="http://www.csser.com/tag">标签</a><div class="menu"> <div>Loading</div><hr><a href="http://www.csser.com/tag" title="所有标签"> <i class="icon-tags icon-white"></i> 所有标签 TOP 50</a></div></li><li class="active"><a href="http://www.csser.com/board">贴板</a><div class="menu"><a href="http://www.csser.com/board/4f4e890bd8a591175600001e"> <i class="icon-exclamation-sign icon-white"></i> 什么是贴板？</a></div></li><li><a href="http://www.csser.com/question">社区</a></li></ul><ul class="nav pull-right"><li><a href="http://www.csser.com/login">登录</a></li><li><a href="http://www.csser.com/register">注册</a></li></ul></div></div></div></div><div class="container"><div class="row"><div class="span8"><div class="mod board-show"><h1><i class="icon-book"></i> Express.js 中文入门指引手册</h1><div class="content"><p>
	<a href="http://expressjs.com/" target="_blank">Express</a><span> 是基于 </span><a href="http://nodejs.org/" target="_blank">Node.js</a><span>，高性能、一流的web开发框架。</span> 
</p>
<p>
	本手册由一回于 2011-4-24 首次翻译，如今已经过去接近一年，express 最新的版本已经与当时翻译有些脱节，为了方便内容更新，将使用 csser 开发的贴板功能进行维护，也方便大家针对细节进行讨论，并请指出翻译不当之处。
</p></div><div class="meta"><span data-time="1333259250160" class="date">2012-04-01 13:47</span><span class="text">84321 次浏览</span><span class="tags"><a href="http://www.csser.com/tag/nodejs" title="NodeJS">#NodeJS</a><a href="http://www.csser.com/tag/express" title="Express">#Express</a></span><span class="pull-right"><a href="javascript:;" data-id="4f77e6f996ca600f78000936" data-type="board" data-cmd="follow" class="btn btn-mini btn-inverse do-follow">关注</a><span class="badge badge-warning">91</span><a href="http://v.t.sina.com.cn/share/share.php?appkey=2211250423&amp;ralateUid=1863470520&amp;url=http%3A%2F%2Fwww.csser.com%2Fboard%2F4f77e6f996ca600f78000936&amp;title=Express.js%20%E4%B8%AD%E6%96%87%E5%85%A5%E9%97%A8%E6%8C%87%E5%BC%95%E6%89%8B%E5%86%8C" title="分享到新浪微博" target="_blank" class="share sina"></a><a href="http://v.t.qq.com/share/share.php?appkey=3f856864fe374cff86c65bd270b1b46d&amp;title=Express.js%20%E4%B8%AD%E6%96%87%E5%85%A5%E9%97%A8%E6%8C%87%E5%BC%95%E6%89%8B%E5%86%8C&amp;url=http%3A%2F%2Fwww.csser.com%2Fboard%2F4f77e6f996ca600f78000936&amp;site=http%3A%2F%2Fwww.csser.com" title="分享到腾讯微博" target="_blank" class="share tencent"></a></span></div><div class="line"></div><div class="form-post"><form id="form-post" method="post" action="/post" class="form"><input id="bid" name="bid" value="4f77e6f996ca600f78000936" type="hidden"><input id="_csrf" name="_csrf" value="Jndw00ARDdpETpVnePRX4qtP" type="hidden"><div class="control-group"><label class="control-label">贴的标题</label><div class="controls"><input id="title" name="title" type="text"><span class="help-inline">请填写名称或标题</span></div></div><div class="control-group"><label class="control-label">贴的内容</label><div class="controls"><div style="width: 70%;" class="ke-container ke-container-simple"><div unselectable="on" class="ke-toolbar" style="display:block;"><span class="ke-outline" data-name="source" title="HTML代码" unselectable="on"><span class="ke-toolbar-icon ke-toolbar-icon-url ke-icon-source" unselectable="on"></span></span><span class="ke-outline" data-name="fullscreen" title="全屏显示(Esc)" unselectable="on"><span class="ke-toolbar-icon ke-toolbar-icon-url ke-icon-fullscreen" unselectable="on"></span></span><span class="ke-inline-block ke-separator"></span><span class="ke-outline" data-name="link" title="超级链接" unselectable="on"><span class="ke-toolbar-icon ke-toolbar-icon-url ke-icon-link" unselectable="on"></span></span><span class="ke-outline" data-name="formatblock" title="段落" unselectable="on"><span class="ke-toolbar-icon ke-toolbar-icon-url ke-icon-formatblock" unselectable="on"></span></span><span class="ke-outline" data-name="insertorderedlist" title="编号" unselectable="on"><span class="ke-toolbar-icon ke-toolbar-icon-url ke-icon-insertorderedlist" unselectable="on"></span></span><span class="ke-outline" data-name="insertunorderedlist" title="项目符号" unselectable="on"><span class="ke-toolbar-icon ke-toolbar-icon-url ke-icon-insertunorderedlist" unselectable="on"></span></span><span class="ke-inline-block ke-separator"></span><span class="ke-outline" data-name="justifyleft" title="左对齐" unselectable="on"><span class="ke-toolbar-icon ke-toolbar-icon-url ke-icon-justifyleft" unselectable="on"></span></span><span class="ke-outline" data-name="justifycenter" title="居中" unselectable="on"><span class="ke-toolbar-icon ke-toolbar-icon-url ke-icon-justifycenter" unselectable="on"></span></span><span class="ke-outline" data-name="justifyright" title="右对齐" unselectable="on"><span class="ke-toolbar-icon ke-toolbar-icon-url ke-icon-justifyright" unselectable="on"></span></span><span class="ke-inline-block ke-separator"></span><span class="ke-outline" data-name="image" title="添加图片" unselectable="on"><span class="ke-toolbar-icon ke-toolbar-icon-url ke-icon-image" unselectable="on"></span></span><span class="ke-outline" data-name="code" title="插入程序代码" unselectable="on"><span class="ke-toolbar-icon ke-toolbar-icon-url ke-icon-code" unselectable="on"></span></span><span class="ke-outline" data-name="inlinecode" title="强调文字" unselectable="on"><span class="ke-toolbar-icon ke-toolbar-icon-url ke-icon-inlinecode" unselectable="on"></span></span></div><div class="ke-edit" style="display: block; height: 180px;"><iframe style="width: 100%; height: 180px;" class="ke-edit-iframe" hidefocus="true" frameborder="0"></iframe><textarea style="width: 100%; height: 180px; display: none;" class="ke-edit-textarea" hidefocus="true"></textarea></div><div class="ke-statusbar"><span class="ke-inline-block ke-statusbar-center-icon"></span><span class="ke-inline-block ke-statusbar-right-icon"></span></div></div><textarea style="display: none;" id="content" name="content" class="textarea"></textarea></div></div><div class="form-actions control-group"><input name="dosubmit" value="贴内容" class="btn btn-primary" type="submit"><a href="javascript:;" class="btn cancel">关闭</a></div></form></div><div class="posts"><div class="post"><div class="post-panel"><h1><i class="icon-forward"></i> express 的安装</h1><div class="post-content"><pre class="prettyprint"><span class="pln">$ npm install express</span></pre>
<p>
	或者
</p>
<p>
</p><pre class="prettyprint"><span class="pln">$ npm install </span><span class="pun">-</span><span class="pln">g express</span></pre>
<p></p></div></div><div class="cmd"><div class="owner"></div><a href="javascript:;" class="add-review">3 条评论</a><span class="bull">•</span><a href="http://www.csser.com/user/xianlihua" title="一回">一回</a><span class="bull">•</span><span class="date" data-time="1333258098995">2012-04-01 13:28</span></div><div class="reviews"><ul class="unstyled"><li class="loading">评论载入中，请稍候……</li></ul><form method="post" class="form" id="form-breview-4f77e772be3baa0d78001470" action="/breview"><input name="bid" value="4f77e772be3baa0d78001470" type="hidden"><div class="control-group"><div class="controls"><textarea class="add-qreview textarea" name="review" id="review"></textarea></div></div><div class="form-actions"><input name="dosubmit" value="添加评论" class="btn btn-primary" type="submit"><a href="javascript:;" class="btn cancel">关闭</a></div></form></div></div><div class="post"><div class="post-panel"><h1><i class="icon-forward"></i> 创建服务器</h1><div class="post-content"><p>
	要创建 <code>express.HTTPServer</code> 的实例，只需简单的调用 <code>createServer()</code> 方法即可。通过 <code>HTTPServer</code> 实例 <code>app</code> 我们可以定义基于 HTTP 动作（HTTP verbs）的路由（routes），本例中为 <code>app.get()</code>。
</p>
<pre class="prettyprint"><span class="kwd">var</span><span class="pln"> app </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">require</span><span class="pun">(</span><span class="str">'express'</span><span class="pun">).</span><span class="pln">createServer</span><span class="pun">();</span><span class="pln">

app</span><span class="pun">.</span><span class="kwd">get</span><span class="pun">(</span><span class="str">'/'</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">req</span><span class="pun">,</span><span class="pln"> res</span><span class="pun">){</span><span class="pln">
  res</span><span class="pun">.</span><span class="pln">send</span><span class="pun">(</span><span class="str">'hello world from csser.com!'</span><span class="pun">);</span><span class="pln">
</span><span class="pun">});</span><span class="pln">

app</span><span class="pun">.</span><span class="pln">listen</span><span class="pun">(</span><span class="lit">3000</span><span class="pun">);</span></pre></div></div><div class="cmd"><div class="owner"></div><a href="javascript:;" class="add-review">5 条评论</a><span class="bull">•</span><a href="http://www.csser.com/user/xianlihua" title="一回">一回</a><span class="bull">•</span><span class="date" data-time="1333258278457">2012-04-01 13:31</span></div><div class="reviews"><ul class="unstyled"><li class="loading">评论载入中，请稍候……</li></ul><form method="post" class="form" id="form-breview-4f77e82696ca600f7800097f" action="/breview"><input name="bid" value="4f77e82696ca600f7800097f" type="hidden"><div class="control-group"><div class="controls"><textarea class="add-qreview textarea" name="review" id="review"></textarea></div></div><div class="form-actions"><input name="dosubmit" value="添加评论" class="btn btn-primary" type="submit"><a href="javascript:;" class="btn cancel">关闭</a></div></form></div></div><div class="post"><div class="post-panel"><h1><i class="icon-forward"></i> 创建 HTTPS 服务器</h1><div class="post-content"><p>
	要初始化一个<code>express.HTTPSServer</code>实例，与上例相似，不同的是在<code>createServer</code>方法我们传入一个对象作为配置参数，该对象接受 <code>key</code>， <code>cert</code> 和其它在<a href="http://nodejs.org/docs/v0.4.6/api/https.html#https.createServer" target="_blank">NodeJS https文档</a>中提到的配置参数。
</p>
<pre class="prettyprint"><span class="pln"> </span><span class="kwd">var</span><span class="pln"> app </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">require</span><span class="pun">(</span><span class="str">'express'</span><span class="pun">).</span><span class="pln">createServer</span><span class="pun">({</span><span class="pln"> key</span><span class="pun">:</span><span class="pln"> </span><span class="pun">...</span><span class="pln"> </span><span class="pun">});</span></pre></div></div><div class="cmd"><div class="owner"></div><a href="javascript:;" class="add-review">添加评论</a><span class="bull">•</span><a href="http://www.csser.com/user/xianlihua" title="一回">一回</a><span class="bull">•</span><span class="date" data-time="1333258369150">2012-04-01 13:32</span></div><div class="reviews"><ul class="unstyled"><li class="loading">还没有评论</li></ul><form method="post" class="form" id="form-breview-4f77e88196ca600f78000985" action="/breview"><input name="bid" value="4f77e88196ca600f78000985" type="hidden"><div class="control-group"><div class="controls"><textarea class="add-qreview textarea" name="review" id="review"></textarea></div></div><div class="form-actions"><input name="dosubmit" value="添加评论" class="btn btn-primary" type="submit"><a href="javascript:;" class="btn cancel">关闭</a></div></form></div></div><div class="post"><div class="post-panel"><h1><i class="icon-forward"></i> 配置</h1><div class="post-content"><p>
	Express支持多工作环境，比如<code>生产环境</code>和<code>开发环境</code>等。开发者可以使用<code>configure()</code>方法根据当前环境的需要进行设置，当<code>configure()</code>没有传入环境名称时，它会在各环境之前被调用（一回注：相当于被各个明确环境所共享）。
</p>
<p>
	下面的示例我们只抛出异常（<code>dumpException</code>），并且在<code>开发模式</code>对异常堆栈的输出做出响应，但是不论对开发或者生产环境我们都使用了<code>methodOverride</code>和<code>bodyParser</code>。特别注意对<code>app.router</code>的使用，它可以被用来设置应用的<code>路由</code>（可选），否则首次对<code>app.get()</code>、<code>app.post()</code>等的调用会设置路由。
</p>
<pre class="prettyprint"><span class="com">// 定义共享环境</span><span class="pln">
app</span><span class="pun">.</span><span class="pln">configure</span><span class="pun">(</span><span class="kwd">function</span><span class="pun">(){</span><span class="pln">
    app</span><span class="pun">.</span><span class="kwd">use</span><span class="pun">(</span><span class="pln">express</span><span class="pun">.</span><span class="pln">methodOverride</span><span class="pun">());</span><span class="pln">
    app</span><span class="pun">.</span><span class="kwd">use</span><span class="pun">(</span><span class="pln">express</span><span class="pun">.</span><span class="pln">bodyParser</span><span class="pun">());</span><span class="pln">
    app</span><span class="pun">.</span><span class="kwd">use</span><span class="pun">(</span><span class="pln">app</span><span class="pun">.</span><span class="pln">router</span><span class="pun">);</span><span class="pln">
</span><span class="pun">});</span><span class="pln">

</span><span class="com">// 定义开发环境</span><span class="pln">
app</span><span class="pun">.</span><span class="pln">configure</span><span class="pun">(</span><span class="str">'development'</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(){</span><span class="pln">
    app</span><span class="pun">.</span><span class="kwd">use</span><span class="pun">(</span><span class="pln">express</span><span class="pun">.</span><span class="kwd">static</span><span class="pun">(</span><span class="pln">__dirname </span><span class="pun">+</span><span class="pln"> </span><span class="str">'/public'</span><span class="pun">));</span><span class="pln">
    app</span><span class="pun">.</span><span class="kwd">use</span><span class="pun">(</span><span class="pln">express</span><span class="pun">.</span><span class="pln">errorHandler</span><span class="pun">({</span><span class="pln"> dumpExceptions</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">,</span><span class="pln"> showStack</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">true</span><span class="pln"> </span><span class="pun">}));</span><span class="pln">
</span><span class="pun">});</span><span class="pln">

</span><span class="com">// 定义生产环境</span><span class="pln">
app</span><span class="pun">.</span><span class="pln">configure</span><span class="pun">(</span><span class="str">'production'</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(){</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> oneYear </span><span class="pun">=</span><span class="pln"> </span><span class="lit">31557600000</span><span class="pun">;</span><span class="pln">
    app</span><span class="pun">.</span><span class="kwd">use</span><span class="pun">(</span><span class="pln">express</span><span class="pun">.</span><span class="kwd">static</span><span class="pun">(</span><span class="pln">__dirname </span><span class="pun">+</span><span class="pln"> </span><span class="str">'/public'</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> maxAge</span><span class="pun">:</span><span class="pln"> oneYear </span><span class="pun">}));</span><span class="pln">
    app</span><span class="pun">.</span><span class="kwd">use</span><span class="pun">(</span><span class="pln">express</span><span class="pun">.</span><span class="pln">errorHandler</span><span class="pun">());</span><span class="pln">
</span><span class="pun">});</span></pre>
<p>
	对于内部和多重设置（internal和arbitrary），Express提供了 <code>set(key[, val])</code>, <code>enable(key)</code>, <code>disable(key)</code>等方法：
</p>
<pre class="prettyprint"><span class="pln">app</span><span class="pun">.</span><span class="pln">configure</span><span class="pun">(</span><span class="kwd">function</span><span class="pun">(){</span><span class="pln">
   app</span><span class="pun">.</span><span class="kwd">set</span><span class="pun">(</span><span class="str">'views'</span><span class="pun">,</span><span class="pln"> __dirname </span><span class="pun">+</span><span class="pln"> </span><span class="str">'/views'</span><span class="pun">);</span><span class="pln">
   app</span><span class="pun">.</span><span class="kwd">set</span><span class="pun">(</span><span class="str">'views'</span><span class="pun">);</span><span class="pln">
   </span><span class="com">// =&gt; "/absolute/path/to/views"</span><span class="pln">

   app</span><span class="pun">.</span><span class="pln">enable</span><span class="pun">(</span><span class="str">'some feature'</span><span class="pun">);</span><span class="pln">
   </span><span class="com">// 与 app.set('some feature', true); 相同</span><span class="pln">

   app</span><span class="pun">.</span><span class="pln">disable</span><span class="pun">(</span><span class="str">'some feature'</span><span class="pun">);</span><span class="pln">
   </span><span class="com">// 与 app.set('some feature', false); 相同</span><span class="pln">

   app</span><span class="pun">.</span><span class="pln">enabled</span><span class="pun">(</span><span class="str">'some feature'</span><span class="pun">)</span><span class="pln">
   </span><span class="com">// =&gt; false</span><span class="pln">
</span><span class="pun">});</span></pre>
<p>
	要修改环境，可以通过设置<code>NODE_ENV</code>环境变量来实现，例如：
</p>
<pre class="prettyprint"><span class="pln">$ NODE_ENV</span><span class="pun">=</span><span class="pln">production node app</span><span class="pun">.</span><span class="pln">js</span></pre>
<p>
	这很<code>重要</code>，因为许多的缓存机制只有在生产环境<code>才会启用</code>。
</p></div></div><div class="cmd"><div class="owner"></div><a href="javascript:;" class="add-review">7 条评论</a><span class="bull">•</span><a href="http://www.csser.com/user/xianlihua" title="一回">一回</a><span class="bull">•</span><span class="date" data-time="1333258459960">2012-04-01 13:34</span></div><div class="reviews"><ul class="unstyled"><li class="loading">评论载入中，请稍候……</li></ul><form method="post" class="form" id="form-breview-4f77e8db96ca600f780009f3" action="/breview"><input name="bid" value="4f77e8db96ca600f780009f3" type="hidden"><div class="control-group"><div class="controls"><textarea class="add-qreview textarea" name="review" id="review"></textarea></div></div><div class="form-actions"><input name="dosubmit" value="添加评论" class="btn btn-primary" type="submit"><a href="javascript:;" class="btn cancel">关闭</a></div></form></div></div><div class="post"><div class="post-panel"><h1><i class="icon-forward"></i> 设置</h1><div class="post-content"><p>
	Express 支持以下设置项：
</p>
<ul>
	<li>
		home为res.redirect()提供应用的基准路径，透明的处理已安装的应用。
	</li>
	<li>
		views视图（views）层的根目录，默认指向CWD/views
	</li>
	<li>
		view engine默认的视图（view）引擎的名字，不包含扩展名。
	</li>
	<li>
		view options用于设置全局视图选项的对象
	</li>
</ul></div></div><div class="cmd"><div class="owner"></div><a href="javascript:;" class="add-review">2 条评论</a><span class="bull">•</span><a href="http://www.csser.com/user/xianlihua" title="一回">一回</a><span class="bull">•</span><span class="date" data-time="1333258516070">2012-04-01 13:35</span></div><div class="reviews"><ul class="unstyled"><li class="loading">评论载入中，请稍候……</li></ul><form method="post" class="form" id="form-breview-4f77e914be3baa0d780014bf" action="/breview"><input name="bid" value="4f77e914be3baa0d780014bf" type="hidden"><div class="control-group"><div class="controls"><textarea class="add-qreview textarea" name="review" id="review"></textarea></div></div><div class="form-actions"><input name="dosubmit" value="添加评论" class="btn btn-primary" type="submit"><a href="javascript:;" class="btn cancel">关闭</a></div></form></div></div><div class="post"><div class="post-panel"><h1><i class="icon-forward"></i> 路由</h1><div class="post-content"><p>
	Express利用HTTP动作提供了有意义并富有表现力的URL映射API，例如我们可能想让用户帐号的URL看起来像<code>/user/12</code>的样子，下面的例子就能实现这样的路由，其中与占位标识符（本例为:id）相关的值可以被<code>req.params</code>获取到。
</p>
<pre class="prettyprint"><span class="pln">app</span><span class="pun">.</span><span class="kwd">get</span><span class="pun">(</span><span class="str">'/user/:id'</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">req</span><span class="pun">,</span><span class="pln"> res</span><span class="pun">){</span><span class="pln">
    res</span><span class="pun">.</span><span class="pln">send</span><span class="pun">(</span><span class="str">'user '</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> req</span><span class="pun">.</span><span class="kwd">params</span><span class="pun">.</span><span class="pln">id</span><span class="pun">);</span><span class="pln">
</span><span class="pun">});</span></pre>
<p>
	上例中当我们访问<code>/user/12</code>时返回“user 12”, csser注：app.get相当于在服务器注册了一个监听get请求事件的侦听器，当请求的URL满足第一个参数时，执行后面的回调函数，该过程是异步的。
</p>
<p>
	路由是一个可以被内部<code>编译</code>成<code>正则表达式</code>的简单字符串，比如当<code>/user/:id</code>被编译后，被内部编译后的正则表达式字符串看起来会是下面的样子（简化后）：
</p>
<pre class="prettyprint"><span class="pln">\/user\/</span><span class="pun">([^</span><span class="pln">\/</span><span class="pun">]+)</span><span class="pln">\/</span><span class="pun">?</span></pre>
<p>
	要实现复杂点的，我们可以传入正则表达式直接量，因为正则捕获组是匿名的因此我们可以通过<code>req.params</code>进行访问，第一个捕获组应该是<code>req.params[0]</code>，第二个应该是<code>req.params[1]</code>，以此类推。
</p>
<pre class="prettyprint"><span class="pln">app</span><span class="pun">.</span><span class="kwd">get</span><span class="pun">(</span><span class="str">/^\/users?(?:\/(\d+)(?:\.\.(\d+))?)?/</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">req</span><span class="pun">,</span><span class="pln"> res</span><span class="pun">){</span><span class="pln">
    res</span><span class="pun">.</span><span class="pln">send</span><span class="pun">(</span><span class="pln">req</span><span class="pun">.</span><span class="kwd">params</span><span class="pun">);</span><span class="pln">
</span><span class="pun">});</span></pre>
<p>
	通过Linux的curl命令来测试我们定义的路由：
</p>
<pre class="prettyprint"><span class="pln">$ curl http</span><span class="pun">:</span><span class="com">//cssercom:3000/user</span><span class="pln">
</span><span class="pun">[</span><span class="kwd">null</span><span class="pun">,</span><span class="kwd">null</span><span class="pun">]</span><span class="pln">
$ curl http</span><span class="pun">:</span><span class="com">//cssercom:3000/users</span><span class="pln">
</span><span class="pun">[</span><span class="kwd">null</span><span class="pun">,</span><span class="kwd">null</span><span class="pun">]</span><span class="pln">
$ curl http</span><span class="pun">:</span><span class="com">//cssercom:3000/users/1</span><span class="pln">
</span><span class="pun">[</span><span class="str">"1"</span><span class="pun">,</span><span class="kwd">null</span><span class="pun">]</span><span class="pln">
$ curl http</span><span class="pun">:</span><span class="com">//cssercom:3000/users/1..15</span><span class="pln">
</span><span class="pun">[</span><span class="str">"1"</span><span class="pun">,</span><span class="str">"15"</span><span class="pun">]</span></pre>
<p>
	下面是一些路由例子，以及与之相匹配的关联路径：
</p>
<pre class="prettyprint"><span class="pln"> </span><span class="str">"/user/:id"</span><span class="pln">
</span><span class="pun">/</span><span class="pln">user</span><span class="pun">/</span><span class="lit">12</span><span class="pln">

</span><span class="str">"/users/:id?"</span><span class="pln">
</span><span class="pun">/</span><span class="pln">users</span><span class="pun">/</span><span class="lit">5</span><span class="pln">
</span><span class="pun">/</span><span class="pln">users

</span><span class="str">"/files/*"</span><span class="pln">
</span><span class="pun">/</span><span class="pln">files</span><span class="pun">/</span><span class="pln">jquery</span><span class="pun">.</span><span class="pln">js
</span><span class="pun">/</span><span class="pln">files</span><span class="pun">/</span><span class="pln">javascripts</span><span class="pun">/</span><span class="pln">jquery</span><span class="pun">.</span><span class="pln">js

</span><span class="str">"/file/*.*"</span><span class="pln">
</span><span class="pun">/</span><span class="pln">files</span><span class="pun">/</span><span class="pln">jquery</span><span class="pun">.</span><span class="pln">js
</span><span class="pun">/</span><span class="pln">files</span><span class="pun">/</span><span class="pln">javascripts</span><span class="pun">/</span><span class="pln">jquery</span><span class="pun">.</span><span class="pln">js

</span><span class="str">"/user/:id/:operation?"</span><span class="pln">
</span><span class="pun">/</span><span class="pln">user</span><span class="pun">/</span><span class="lit">1</span><span class="pln">
</span><span class="pun">/</span><span class="pln">user</span><span class="pun">/</span><span class="lit">1</span><span class="pun">/</span><span class="pln">edit

</span><span class="str">"/products.:format"</span><span class="pln">
</span><span class="pun">/</span><span class="pln">products</span><span class="pun">.</span><span class="pln">json
</span><span class="pun">/</span><span class="pln">products</span><span class="pun">.</span><span class="pln">xml

</span><span class="str">"/products.:format?"</span><span class="pln">
</span><span class="pun">/</span><span class="pln">products</span><span class="pun">.</span><span class="pln">json
</span><span class="pun">/</span><span class="pln">products</span><span class="pun">.</span><span class="pln">xml
</span><span class="pun">/</span><span class="pln">products

</span><span class="str">"/user/:id.:format?"</span><span class="pln">
</span><span class="pun">/</span><span class="pln">user</span><span class="pun">/</span><span class="lit">12</span><span class="pln">
</span><span class="pun">/</span><span class="pln">user</span><span class="pun">/</span><span class="lit">12.json</span></pre>
<p>
	另外，我们可以通过<code>POST</code>方式提交json数据，然后利用<code>bodyParser</code>中间件解析json请求体并把json数据返回给客户端：
</p>
<pre class="prettyprint"><span class="kwd">var</span><span class="pln"> express </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">require</span><span class="pun">(</span><span class="str">'express'</span><span class="pun">)</span><span class="pln">
  </span><span class="pun">,</span><span class="pln"> app </span><span class="pun">=</span><span class="pln"> express</span><span class="pun">.</span><span class="pln">createServer</span><span class="pun">();</span><span class="pln">

app</span><span class="pun">.</span><span class="kwd">use</span><span class="pun">(</span><span class="pln">express</span><span class="pun">.</span><span class="pln">bodyParser</span><span class="pun">());</span><span class="pln">

app</span><span class="pun">.</span><span class="pln">post</span><span class="pun">(</span><span class="str">'/'</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">req</span><span class="pun">,</span><span class="pln"> res</span><span class="pun">){</span><span class="pln">
  res</span><span class="pun">.</span><span class="pln">send</span><span class="pun">(</span><span class="pln">req</span><span class="pun">.</span><span class="pln">body</span><span class="pun">);</span><span class="pln">
</span><span class="pun">});</span><span class="pln">

app</span><span class="pun">.</span><span class="pln">listen</span><span class="pun">(</span><span class="lit">3000</span><span class="pun">);</span></pre>
<p>
	通常我们所使用的占位符（比如/user/:id）都没有任何限制，即用户可以传入各种各样数据类型的id值，如果我们希望限制用户id为数字，可以这样写<code>“/user/:id(\d+)”</code>，这样就能保证只有该占位符数据类型为数值类型才会进行路由的相关处理。
</p></div></div><div class="cmd"><div class="owner"></div><a href="javascript:;" class="add-review">4 条评论</a><span class="bull">•</span><a href="http://www.csser.com/user/xianlihua" title="一回">一回</a><span class="bull">•</span><span class="date" data-time="1333258568038">2012-04-01 13:36</span></div><div class="reviews"><ul class="unstyled"><li class="loading">评论载入中，请稍候……</li></ul><form method="post" class="form" id="form-breview-4f77e94896ca600f780009f8" action="/breview"><input name="bid" value="4f77e94896ca600f780009f8" type="hidden"><div class="control-group"><div class="controls"><textarea class="add-qreview textarea" name="review" id="review"></textarea></div></div><div class="form-actions"><input name="dosubmit" value="添加评论" class="btn btn-primary" type="submit"><a href="javascript:;" class="btn cancel">关闭</a></div></form></div></div><div class="post"><div class="post-panel"><h1><i class="icon-forward"></i> 路由控制</h1><div class="post-content"><p>
	一个应用中可以定义多个路由，我们可以控制以令其转向下一个路由，Express提供了第<code>三</code>个参数即<code>next()</code>函数。当一个模式不被匹配时，控制将被转回Connect（Express基于Connect模块），同时中间件会继续按照它们在<code>use()</code>中增加的顺序来执行。当多个定义的路由都可能匹配同一个URL时也是如此，除非某个路由并不调用<code>next()</code>且已将响应输出到客户端，否则它们也将按顺序执行。
</p>
<pre class="prettyprint"><span class="pln">app</span><span class="pun">.</span><span class="kwd">get</span><span class="pun">(</span><span class="str">'/users/:id?'</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">req</span><span class="pun">,</span><span class="pln"> res</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">next</span><span class="pun">){</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> id </span><span class="pun">=</span><span class="pln"> req</span><span class="pun">.</span><span class="kwd">params</span><span class="pun">.</span><span class="pln">id</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">id</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="com">// 一回注：如果在这里就将响应内容输出给客户端，那么后续的URL映射将不会被调用</span><span class="pln">
    </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">next</span><span class="pun">();</span><span class="pln"> </span><span class="com">// 将控制转向下一个符合URL的路由</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
</span><span class="pun">});</span><span class="pln">

app</span><span class="pun">.</span><span class="kwd">get</span><span class="pun">(</span><span class="str">'/users'</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">req</span><span class="pun">,</span><span class="pln"> res</span><span class="pun">){</span><span class="pln">
    </span><span class="com">// do something else</span><span class="pln">
</span><span class="pun">});</span></pre>
<p>
	<code>app.all()</code>方法可以对所有HTTP动作应用单一调用入口，这在有些情况下很有用。下面我们使用该功能来从我们的模拟数据库中加载一个用户，并把它分配给<code>req.user</code>。
</p>
<pre class="prettyprint"><span class="kwd">var</span><span class="pln"> express </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">require</span><span class="pun">(</span><span class="str">'express'</span><span class="pun">)</span><span class="pln">
  </span><span class="pun">,</span><span class="pln"> app </span><span class="pun">=</span><span class="pln"> express</span><span class="pun">.</span><span class="pln">createServer</span><span class="pun">();</span><span class="pln">

</span><span class="kwd">var</span><span class="pln"> users </span><span class="pun">=</span><span class="pln"> </span><span class="pun">[{</span><span class="pln"> name</span><span class="pun">:</span><span class="pln"> </span><span class="str">'www.csser.com'</span><span class="pln"> </span><span class="pun">}];</span><span class="pln">

app</span><span class="pun">.</span><span class="pln">all</span><span class="pun">(</span><span class="str">'/user/:id/:op?'</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">req</span><span class="pun">,</span><span class="pln"> res</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">next</span><span class="pun">){</span><span class="pln">
  req</span><span class="pun">.</span><span class="pln">user </span><span class="pun">=</span><span class="pln"> users</span><span class="pun">[</span><span class="pln">req</span><span class="pun">.</span><span class="kwd">params</span><span class="pun">.</span><span class="pln">id</span><span class="pun">];</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">req</span><span class="pun">.</span><span class="pln">user</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">next</span><span class="pun">();</span><span class="pln">
  </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">next</span><span class="pun">(</span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Error</span><span class="pun">(</span><span class="str">'cannot find user '</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> req</span><span class="pun">.</span><span class="kwd">params</span><span class="pun">.</span><span class="pln">id</span><span class="pun">));</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">});</span><span class="pln">

app</span><span class="pun">.</span><span class="kwd">get</span><span class="pun">(</span><span class="str">'/user/:id'</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">req</span><span class="pun">,</span><span class="pln"> res</span><span class="pun">){</span><span class="pln">
  res</span><span class="pun">.</span><span class="pln">send</span><span class="pun">(</span><span class="str">'viewing '</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> req</span><span class="pun">.</span><span class="pln">user</span><span class="pun">.</span><span class="pln">name</span><span class="pun">);</span><span class="pln">
</span><span class="pun">});</span><span class="pln">

app</span><span class="pun">.</span><span class="kwd">get</span><span class="pun">(</span><span class="str">'/user/:id/edit'</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">req</span><span class="pun">,</span><span class="pln"> res</span><span class="pun">){</span><span class="pln">
  res</span><span class="pun">.</span><span class="pln">send</span><span class="pun">(</span><span class="str">'editing '</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> req</span><span class="pun">.</span><span class="pln">user</span><span class="pun">.</span><span class="pln">name</span><span class="pun">);</span><span class="pln">
</span><span class="pun">});</span><span class="pln">

app</span><span class="pun">.</span><span class="pln">put</span><span class="pun">(</span><span class="str">'/user/:id'</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">req</span><span class="pun">,</span><span class="pln"> res</span><span class="pun">){</span><span class="pln">
  res</span><span class="pun">.</span><span class="pln">send</span><span class="pun">(</span><span class="str">'updating '</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> req</span><span class="pun">.</span><span class="pln">user</span><span class="pun">.</span><span class="pln">name</span><span class="pun">);</span><span class="pln">
</span><span class="pun">});</span><span class="pln">

app</span><span class="pun">.</span><span class="kwd">get</span><span class="pun">(</span><span class="str">'*'</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">req</span><span class="pun">,</span><span class="pln"> res</span><span class="pun">){</span><span class="pln">
  res</span><span class="pun">.</span><span class="pln">send</span><span class="pun">(</span><span class="str">'what???'</span><span class="pun">,</span><span class="pln"> </span><span class="lit">404</span><span class="pun">);</span><span class="pln">
</span><span class="pun">});</span><span class="pln">

app</span><span class="pun">.</span><span class="pln">listen</span><span class="pun">(</span><span class="lit">3000</span><span class="pun">);</span></pre></div></div><div class="cmd"><div class="owner"></div><a href="javascript:;" class="add-review">1 条评论</a><span class="bull">•</span><a href="http://www.csser.com/user/xianlihua" title="一回">一回</a><span class="bull">•</span><span class="date" data-time="1333258625771">2012-04-01 13:37</span></div><div class="reviews"><ul class="unstyled"><li class="loading">评论载入中，请稍候……</li></ul><form method="post" class="form" id="form-breview-4f77e98196ca600f780009fd" action="/breview"><input name="bid" value="4f77e98196ca600f780009fd" type="hidden"><div class="control-group"><div class="controls"><textarea class="add-qreview textarea" name="review" id="review"></textarea></div></div><div class="form-actions"><input name="dosubmit" value="添加评论" class="btn btn-primary" type="submit"><a href="javascript:;" class="btn cancel">关闭</a></div></form></div></div><div class="post"><div class="post-panel"><h1><i class="icon-forward"></i> 中间件</h1><div class="post-content"><p>
	中间件可以通过<a href="http://github.com/senchalabs/connect" target="_blank">Connect</a>传入<code>express.createServer()</code>，就像正常的连接服务器一样，比如：
</p>
<pre class="prettyprint"><span class="kwd">var</span><span class="pln"> express </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">require</span><span class="pun">(</span><span class="str">'express'</span><span class="pun">);</span><span class="pln">

</span><span class="kwd">var</span><span class="pln"> app </span><span class="pun">=</span><span class="pln"> express</span><span class="pun">.</span><span class="pln">createServer</span><span class="pun">(</span><span class="pln">
    express</span><span class="pun">.</span><span class="pln">logger</span><span class="pun">(),</span><span class="pln">
    express</span><span class="pun">.</span><span class="pln">bodyParser</span><span class="pun">()</span><span class="pln">
</span><span class="pun">);</span></pre>
<p>
	另外，在<code>configure()</code>函数块中利用<code>use()</code>函数增加中间件，也是一种很好的方式。
</p>
<pre class="prettyprint"><span class="pln">app</span><span class="pun">.</span><span class="kwd">use</span><span class="pun">(</span><span class="pln">express</span><span class="pun">.</span><span class="pln">logger</span><span class="pun">({</span><span class="pln"> format</span><span class="pun">:</span><span class="pln"> </span><span class="str">':method :uri'</span><span class="pln"> </span><span class="pun">}));</span></pre>
<p>
	通常连接中间件可以通过<code>require("connect")</code>的方式，如：
</p>
<pre class="prettyprint"><span class="kwd">var</span><span class="pln"> connect </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">require</span><span class="pun">(</span><span class="str">'connect'</span><span class="pun">);</span><span class="pln">
app</span><span class="pun">.</span><span class="kwd">use</span><span class="pun">(</span><span class="pln">connect</span><span class="pun">.</span><span class="pln">logger</span><span class="pun">());</span><span class="pln">
app</span><span class="pun">.</span><span class="kwd">use</span><span class="pun">(</span><span class="pln">connect</span><span class="pun">.</span><span class="pln">bodyParser</span><span class="pun">());</span></pre>
<p>
	这让人感觉有些不太爽，于是express重新输出了（re-exports)这些中间件属性，但是在使用上保持了<code>一致性</code>：
</p>
<pre class="prettyprint"><span class="pln">app</span><span class="pun">.</span><span class="kwd">use</span><span class="pun">(</span><span class="pln">express</span><span class="pun">.</span><span class="pln">logger</span><span class="pun">());</span><span class="pln">
app</span><span class="pun">.</span><span class="kwd">use</span><span class="pun">(</span><span class="pln">express</span><span class="pun">.</span><span class="pln">bodyParser</span><span class="pun">());</span></pre></div></div><div class="cmd"><div class="owner"></div><a href="javascript:;" class="add-review">8 条评论</a><span class="bull">•</span><a href="http://www.csser.com/user/xianlihua" title="一回">一回</a><span class="bull">•</span><span class="date" data-time="1333258665996">2012-04-01 13:37</span></div><div class="reviews"><ul class="unstyled"><li class="loading">评论载入中，请稍候……</li></ul><form method="post" class="form" id="form-breview-4f77e9a996ca600f78000a02" action="/breview"><input name="bid" value="4f77e9a996ca600f78000a02" type="hidden"><div class="control-group"><div class="controls"><textarea class="add-qreview textarea" name="review" id="review"></textarea></div></div><div class="form-actions"><input name="dosubmit" value="添加评论" class="btn btn-primary" type="submit"><a href="javascript:;" class="btn cancel">关闭</a></div></form></div></div><div class="post"><div class="post-panel"><h1><i class="icon-forward"></i> 路由中间件</h1><div class="post-content"><p>
	这里路径映射也可以理解为路由的意思，路由通过传入一个或多个附加的回调函数（或数组）到方法中，从而可以利用特定路由的中间件。该功能对限制访问以及加载路由使用的数据非常有用。
</p>
<p>
	通常情况下异步数据的查询看起来像下面的样子，这里我们使用<code>:id</code>参数，并尝试获取一个用户。
</p>
<pre class="prettyprint"><span class="pln">app</span><span class="pun">.</span><span class="kwd">get</span><span class="pun">(</span><span class="str">'/user/:id'</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">req</span><span class="pun">,</span><span class="pln"> res</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">next</span><span class="pun">){</span><span class="pln">
  loadUser</span><span class="pun">(</span><span class="pln">req</span><span class="pun">.</span><span class="kwd">params</span><span class="pun">.</span><span class="pln">id</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">err</span><span class="pun">,</span><span class="pln"> user</span><span class="pun">){</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">err</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">next</span><span class="pun">(</span><span class="pln">err</span><span class="pun">);</span><span class="pln">
    res</span><span class="pun">.</span><span class="pln">send</span><span class="pun">(</span><span class="str">'Viewing user of csser.com '</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> user</span><span class="pun">.</span><span class="pln">name</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">});</span><span class="pln">
</span><span class="pun">});</span></pre>
<p>
	为了保持代码整洁并且提高可读性，我们可以在中间件内部应用该逻辑。正如你所看到的，将逻辑抽象到中间件里让我们达到一定程度的复用，同时代码更干净。
</p>
<pre class="prettyprint"><span class="kwd">function</span><span class="pln"> loadUser</span><span class="pun">(</span><span class="pln">req</span><span class="pun">,</span><span class="pln"> res</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">next</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="com">// 这里提供假数据，你可以从数据库中获取真实用户信息</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> user </span><span class="pun">=</span><span class="pln"> users</span><span class="pun">[</span><span class="pln">req</span><span class="pun">.</span><span class="kwd">params</span><span class="pun">.</span><span class="pln">id</span><span class="pun">];</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">user</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    req</span><span class="pun">.</span><span class="pln">user </span><span class="pun">=</span><span class="pln"> user</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">next</span><span class="pun">();</span><span class="pln">
  </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">next</span><span class="pun">(</span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Error</span><span class="pun">(</span><span class="str">'不存在的用户 '</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> req</span><span class="pun">.</span><span class="kwd">params</span><span class="pun">.</span><span class="pln">id</span><span class="pun">));</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

app</span><span class="pun">.</span><span class="kwd">get</span><span class="pun">(</span><span class="str">'/user/:id'</span><span class="pun">,</span><span class="pln"> loadUser</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">req</span><span class="pun">,</span><span class="pln"> res</span><span class="pun">){</span><span class="pln">
  res</span><span class="pun">.</span><span class="pln">send</span><span class="pun">(</span><span class="str">'正在查看用户 '</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> req</span><span class="pun">.</span><span class="pln">user</span><span class="pun">.</span><span class="pln">name</span><span class="pun">);</span><span class="pln">
</span><span class="pun">});</span></pre>
<p>
	一回注：看到了吗？上面的路径映射的回调函数参数是可以支持多个的。
</p>
<p>
	多重路由中间件可以被按照顺序来执行，从而可以实现更复杂的逻辑，比如限制访问某个用户的访问权限，下面的代码将只允许认证用户才可以编辑其帐号信息。
</p>
<pre class="prettyprint"><span class="kwd">function</span><span class="pln"> andRestrictToSelf</span><span class="pun">(</span><span class="pln">req</span><span class="pun">,</span><span class="pln"> res</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">next</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  req</span><span class="pun">.</span><span class="pln">authenticatedUser</span><span class="pun">.</span><span class="pln">id </span><span class="pun">==</span><span class="pln"> req</span><span class="pun">.</span><span class="pln">user</span><span class="pun">.</span><span class="pln">id
    </span><span class="pun">?</span><span class="pln"> </span><span class="kwd">next</span><span class="pun">()</span><span class="pln">
    </span><span class="pun">:</span><span class="pln"> </span><span class="kwd">next</span><span class="pun">(</span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Error</span><span class="pun">(</span><span class="str">'无权限'</span><span class="pun">));</span><span class="pln">

</span><span class="pun">}</span><span class="pln">

app</span><span class="pun">.</span><span class="kwd">get</span><span class="pun">(</span><span class="str">'/user/:id/edit'</span><span class="pun">,</span><span class="pln"> loadUser</span><span class="pun">,</span><span class="pln"> andRestrictToSelf</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">req</span><span class="pun">,</span><span class="pln"> res</span><span class="pun">){</span><span class="pln">
  res</span><span class="pun">.</span><span class="pln">send</span><span class="pun">(</span><span class="str">'开始编辑用户 '</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> req</span><span class="pun">.</span><span class="pln">user</span><span class="pun">.</span><span class="pln">name</span><span class="pun">);</span><span class="pln">
</span><span class="pun">});</span></pre>
<p>
	请记住中间件是简单的函数，我们还能定义<code>返回</code>中间件的函数，从而可以创建一个更有表现力和更易用的如下方案：
</p>
<pre class="prettyprint"><span class="kwd">function</span><span class="pln"> andRestrictTo</span><span class="pun">(</span><span class="pln">role</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">req</span><span class="pun">,</span><span class="pln"> res</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">next</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    req</span><span class="pun">.</span><span class="pln">authenticatedUser</span><span class="pun">.</span><span class="pln">role </span><span class="pun">==</span><span class="pln"> role
      </span><span class="pun">?</span><span class="pln"> </span><span class="kwd">next</span><span class="pun">()</span><span class="pln">
      </span><span class="pun">:</span><span class="pln"> </span><span class="kwd">next</span><span class="pun">(</span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Error</span><span class="pun">(</span><span class="str">'无权限'</span><span class="pun">));</span><span class="pln">

  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

app</span><span class="pun">.</span><span class="kwd">del</span><span class="pun">(</span><span class="str">'/user/:id'</span><span class="pun">,</span><span class="pln"> loadUser</span><span class="pun">,</span><span class="pln"> andRestrictTo</span><span class="pun">(</span><span class="str">'admin'</span><span class="pun">),</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">req</span><span class="pun">,</span><span class="pln"> res</span><span class="pun">){</span><span class="pln">
  res</span><span class="pun">.</span><span class="pln">send</span><span class="pun">(</span><span class="str">'已删除用户 '</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> req</span><span class="pun">.</span><span class="pln">user</span><span class="pun">.</span><span class="pln">name</span><span class="pun">);</span><span class="pln">
</span><span class="pun">});</span></pre>
<p>
	一回注：app.del的第三个参数之所以可以这样写，是因为其返回的是一个函数，而该函数可以访问’admin’的值，这里涉及到闭包的概念，如有疑问请在CSSer.com查找闭包相关文章。
</p>
<p>
	通常使用的中间件的“栈”可以被作为数组（<code>递归应用</code>）传入，如此可以被混合并能匹配更复杂的功能。
</p>
<pre class="prettyprint"><span class="kwd">var</span><span class="pln"> a </span><span class="pun">=</span><span class="pln"> </span><span class="pun">[</span><span class="pln">middleware1</span><span class="pun">,</span><span class="pln"> middleware2</span><span class="pun">]</span><span class="pln">
  </span><span class="pun">,</span><span class="pln"> b </span><span class="pun">=</span><span class="pln"> </span><span class="pun">[</span><span class="pln">middleware3</span><span class="pun">,</span><span class="pln"> middleware4</span><span class="pun">]</span><span class="pln">
  </span><span class="pun">,</span><span class="pln"> all </span><span class="pun">=</span><span class="pln"> </span><span class="pun">[</span><span class="pln">a</span><span class="pun">,</span><span class="pln"> b</span><span class="pun">];</span><span class="pln">

app</span><span class="pun">.</span><span class="kwd">get</span><span class="pun">(</span><span class="str">'/foo'</span><span class="pun">,</span><span class="pln"> a</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(){});</span><span class="pln">
app</span><span class="pun">.</span><span class="kwd">get</span><span class="pun">(</span><span class="str">'/bar'</span><span class="pun">,</span><span class="pln"> a</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(){});</span><span class="pln">

app</span><span class="pun">.</span><span class="kwd">get</span><span class="pun">(</span><span class="str">'/'</span><span class="pun">,</span><span class="pln"> a</span><span class="pun">,</span><span class="pln"> middleware3</span><span class="pun">,</span><span class="pln"> middleware4</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(){});</span><span class="pln">
app</span><span class="pun">.</span><span class="kwd">get</span><span class="pun">(</span><span class="str">'/'</span><span class="pun">,</span><span class="pln"> a</span><span class="pun">,</span><span class="pln"> b</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(){});</span><span class="pln">
app</span><span class="pun">.</span><span class="kwd">get</span><span class="pun">(</span><span class="str">'/'</span><span class="pun">,</span><span class="pln"> all</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(){});</span></pre>
<p>
	可以去express源码仓库查看完整的<a href="http://github.com/visionmedia/express/blob/master/examples/route-middleware/app.js" target="_blank">路由中间件示例</a>。
</p></div></div><div class="cmd"><div class="owner"></div><a href="javascript:;" class="add-review">1 条评论</a><span class="bull">•</span><a href="http://www.csser.com/user/xianlihua" title="一回">一回</a><span class="bull">•</span><span class="date" data-time="1333258716545">2012-04-01 13:38</span></div><div class="reviews"><ul class="unstyled"><li class="loading">评论载入中，请稍候……</li></ul><form method="post" class="form" id="form-breview-4f77e9dcbe3baa0d78001521" action="/breview"><input name="bid" value="4f77e9dcbe3baa0d78001521" type="hidden"><div class="control-group"><div class="controls"><textarea class="add-qreview textarea" name="review" id="review"></textarea></div></div><div class="form-actions"><input name="dosubmit" value="添加评论" class="btn btn-primary" type="submit"><a href="javascript:;" class="btn cancel">关闭</a></div></form></div></div><div class="post"><div class="post-panel"><h1><i class="icon-forward"></i> HTTP 方法</h1><div class="post-content"><p>
	在CSSer前面的文章中我们已经接触过<code>app.get()</code>多次了，同时Express也提供了对其它HTTP动作的封装，如<code>app.post()</code>, <code>app.del()</code>等。
</p>
<p>
	对于<code>POST</code>最常见的例子，就是当我们提交一个表单时，下面我们在HTML中将表单的method特性设置为“post”，然后需要在服务端定义对该表单提交的路由控制。
</p>
<pre class="prettyprint"><span class="pln"> </span><span class="tag">&lt;form</span><span class="pln"> </span><span class="atn">method</span><span class="pun">=</span><span class="atv">"post"</span><span class="pln"> </span><span class="atn">action</span><span class="pun">=</span><span class="atv">"/"</span><span class="tag">&gt;</span><span class="pln">
   </span><span class="tag">&lt;input</span><span class="pln"> </span><span class="atn">type</span><span class="pun">=</span><span class="atv">"text"</span><span class="pln"> </span><span class="atn">name</span><span class="pun">=</span><span class="atv">"user[name]"</span><span class="pln"> </span><span class="tag">/&gt;</span><span class="pln">
   </span><span class="tag">&lt;input</span><span class="pln"> </span><span class="atn">type</span><span class="pun">=</span><span class="atv">"text"</span><span class="pln"> </span><span class="atn">name</span><span class="pun">=</span><span class="atv">"user[email]"</span><span class="pln"> </span><span class="tag">/&gt;</span><span class="pln">
   </span><span class="tag">&lt;input</span><span class="pln"> </span><span class="atn">type</span><span class="pun">=</span><span class="atv">"submit"</span><span class="pln"> </span><span class="atn">value</span><span class="pun">=</span><span class="atv">"Submit"</span><span class="pln"> </span><span class="tag">/&gt;</span><span class="pln">
</span><span class="tag">&lt;/form&gt;</span></pre>
<p>
	默认情况下Express并不知道该如何处理该请求体，因此我们需要增加bodyParser中间件，用于分析<code>application/x-www-form-urlencoded</code>和<code>application/json</code>请求体，并把变量存入<code>req.body</code>。我们可以像下面的样子来“使用”中间件：
</p>
<pre class="prettyprint"><span class="pln">app</span><span class="pun">.</span><span class="kwd">use</span><span class="pun">(</span><span class="pln">express</span><span class="pun">.</span><span class="pln">bodyParser</span><span class="pun">());</span></pre>
<p>
	接下来下面的路由就可以访问<code>req.body.user</code>对象了，该对象包含客户端提交的<code>name</code>和<code>email</code>属性。
</p>
<pre class="prettyprint"><span class="pln">app</span><span class="pun">.</span><span class="pln">post</span><span class="pun">(</span><span class="str">'/'</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">req</span><span class="pun">,</span><span class="pln"> res</span><span class="pun">){</span><span class="pln">
  console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="pln">req</span><span class="pun">.</span><span class="pln">body</span><span class="pun">.</span><span class="pln">user</span><span class="pun">);</span><span class="pln">
  res</span><span class="pun">.</span><span class="pln">redirect</span><span class="pun">(</span><span class="str">'back'</span><span class="pun">);</span><span class="pln">
</span><span class="pun">});</span></pre>
<p>
	要在表单中使用<code>PUT</code>的HTTP方法，我们可以利用名为<code>_method</code>的隐藏表单域，它能改变HTTP方法。而在服务端，我们首先需要利用<code>methodOverride</code>中间件，把它放在<code>bodyParser</code>中间件下方，从而可以利用包含表单值的<code>req.body</code>。
</p>
<pre class="prettyprint"><span class="pln">app</span><span class="pun">.</span><span class="kwd">use</span><span class="pun">(</span><span class="pln">express</span><span class="pun">.</span><span class="pln">bodyParser</span><span class="pun">());</span><span class="pln">
app</span><span class="pun">.</span><span class="kwd">use</span><span class="pun">(</span><span class="pln">express</span><span class="pun">.</span><span class="pln">methodOverride</span><span class="pun">());</span></pre>
<p>
	之所以需要这样做，是因为这些处理并不总是默认进行的，原因很简单，因为这些对Express的整体功能来说并不是必需的，依据应用的具体需求，你并不一定需要这些功能，如果客户端直接支持<code>PUT</code>和<code>DELETE</code>方法也可以被直接访问到，同时<code>methodOverride</code>为表单提供了强大的解决方案，下面我们展示下PUT的使用：
</p>
<pre class="prettyprint"><span class="tag">&lt;form</span><span class="pln"> </span><span class="atn">method</span><span class="pun">=</span><span class="atv">"post"</span><span class="pln"> </span><span class="atn">action</span><span class="pun">=</span><span class="atv">"/"</span><span class="tag">&gt;</span><span class="pln">
    </span><span class="tag">&lt;input</span><span class="pln"> </span><span class="atn">type</span><span class="pun">=</span><span class="atv">"hidden"</span><span class="pln"> </span><span class="atn">name</span><span class="pun">=</span><span class="atv">"_method"</span><span class="pln"> </span><span class="atn">value</span><span class="pun">=</span><span class="atv">"put"</span><span class="pln"> </span><span class="tag">/&gt;</span><span class="pln">
    </span><span class="tag">&lt;input</span><span class="pln"> </span><span class="atn">type</span><span class="pun">=</span><span class="atv">"text"</span><span class="pln"> </span><span class="atn">name</span><span class="pun">=</span><span class="atv">"user[name]"</span><span class="pln"> </span><span class="tag">/&gt;</span><span class="pln">
    </span><span class="tag">&lt;input</span><span class="pln"> </span><span class="atn">type</span><span class="pun">=</span><span class="atv">"text"</span><span class="pln"> </span><span class="atn">name</span><span class="pun">=</span><span class="atv">"user[email]"</span><span class="pln"> </span><span class="tag">/&gt;</span><span class="pln">
    </span><span class="tag">&lt;input</span><span class="pln"> </span><span class="atn">type</span><span class="pun">=</span><span class="atv">"submit"</span><span class="pln"> </span><span class="atn">value</span><span class="pun">=</span><span class="atv">"Submit"</span><span class="pln"> </span><span class="tag">/&gt;</span><span class="pln">
</span><span class="tag">&lt;/form&gt;</span><span class="pln">

app.put('/', function(){
    console.log(req.body.user);
    res.redirect('back');
});</span></pre></div></div><div class="cmd"><div class="owner"></div><a href="javascript:;" class="add-review">4 条评论</a><span class="bull">•</span><a href="http://www.csser.com/user/xianlihua" title="一回">一回</a><span class="bull">•</span><span class="date" data-time="1333258780313">2012-04-01 13:39</span></div><div class="reviews"><ul class="unstyled"><li class="loading">评论载入中，请稍候……</li></ul><form method="post" class="form" id="form-breview-4f77ea1cbe3baa0d7800153c" action="/breview"><input name="bid" value="4f77ea1cbe3baa0d7800153c" type="hidden"><div class="control-group"><div class="controls"><textarea class="add-qreview textarea" name="review" id="review"></textarea></div></div><div class="form-actions"><input name="dosubmit" value="添加评论" class="btn btn-primary" type="submit"><a href="javascript:;" class="btn cancel">关闭</a></div></form></div></div><div class="post"><div class="post-panel"><h1><i class="icon-forward"></i> 错误处理</h1><div class="post-content"><p>
	Express提供了<code>app.error()</code>方法来接收路由或传入<code>next(err)</code>的异常，下面的示例为不同的页面提供专门的<code>NotFound</code>异常服务：
</p>
<pre class="prettyprint"><span class="kwd">function</span><span class="pln"> </span><span class="typ">NotFound</span><span class="pun">(</span><span class="pln">msg</span><span class="pun">){</span><span class="pln">
  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">name </span><span class="pun">=</span><span class="pln"> </span><span class="str">'NotFound in csser.com'</span><span class="pun">;</span><span class="pln">
  </span><span class="typ">Error</span><span class="pun">.</span><span class="pln">call</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">,</span><span class="pln"> msg</span><span class="pun">);</span><span class="pln">
  </span><span class="typ">Error</span><span class="pun">.</span><span class="pln">captureStackTrace</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">,</span><span class="pln"> arguments</span><span class="pun">.</span><span class="pln">callee</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="typ">NotFound</span><span class="pun">.</span><span class="pln">prototype</span><span class="pun">.</span><span class="pln">__proto__ </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Error</span><span class="pun">.</span><span class="pln">prototype</span><span class="pun">;</span><span class="pln">

app</span><span class="pun">.</span><span class="kwd">get</span><span class="pun">(</span><span class="str">'/404'</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">req</span><span class="pun">,</span><span class="pln"> res</span><span class="pun">){</span><span class="pln">
  </span><span class="kwd">throw</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">NotFound</span><span class="pun">;</span><span class="pln">
</span><span class="pun">});</span><span class="pln">

app</span><span class="pun">.</span><span class="kwd">get</span><span class="pun">(</span><span class="str">'/500'</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">req</span><span class="pun">,</span><span class="pln"> res</span><span class="pun">){</span><span class="pln">
  </span><span class="kwd">throw</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Error</span><span class="pun">(</span><span class="str">'keyboard cat!'</span><span class="pun">);</span><span class="pln">
</span><span class="pun">});</span></pre>
<p>
	像下面一样，我们可以多次调用<code>app.error()</code>，这里我们检查如果是<code>NotFound</code>实例就显示404页面，否则将其传入下一个错误处理。
</p>
<p>
	注意这些处理可以定义在任何地方，它们可以放在路由可以<code>listen()</code>之处。这也允许在<code>configure()</code>块内做定义，于是我们就可以以不同的基于环境的方式处理异常。
</p>
<pre class="prettyprint"><span class="pln">app</span><span class="pun">.</span><span class="pln">error</span><span class="pun">(</span><span class="kwd">function</span><span class="pun">(</span><span class="pln">err</span><span class="pun">,</span><span class="pln"> req</span><span class="pun">,</span><span class="pln"> res</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">next</span><span class="pun">){</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">err </span><span class="kwd">instanceof</span><span class="pln"> </span><span class="typ">NotFound</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        res</span><span class="pun">.</span><span class="pln">render</span><span class="pun">(</span><span class="str">'404.jade'</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">next</span><span class="pun">(</span><span class="pln">err</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
</span><span class="pun">});</span></pre>
<p>
	下面的演示我们假设所有错误都为500错误，但你可以根据喜好选择。例如当node在处理文件系统调用时，就有可能接收到这样的错误对象，其<code>ENOENT</code>的<code>error.code</code>为“no such file or directory”，这时我们可以在错误处理函数中进行处理然后显示特定的页面给用户。
</p>
<pre class="prettyprint"><span class="pln">app</span><span class="pun">.</span><span class="pln">error</span><span class="pun">(</span><span class="kwd">function</span><span class="pun">(</span><span class="pln">err</span><span class="pun">,</span><span class="pln"> req</span><span class="pun">,</span><span class="pln"> res</span><span class="pun">){</span><span class="pln">
   res</span><span class="pun">.</span><span class="pln">render</span><span class="pun">(</span><span class="str">'500.jade'</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> error</span><span class="pun">:</span><span class="pln"> err </span><span class="pun">});</span><span class="pln">
</span><span class="pun">});</span></pre>
<p>
	我们的应用也可以利用Connect <code>errorHandler</code>中间件来汇报异常信息。例如我们想在“开发”环境输出异常到<code>stderr</code>：
</p>
<pre class="prettyprint"><span class="pln">app</span><span class="pun">.</span><span class="kwd">use</span><span class="pun">(</span><span class="pln">express</span><span class="pun">.</span><span class="pln">errorHandler</span><span class="pun">({</span><span class="pln"> dumpExceptions</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">true</span><span class="pln"> </span><span class="pun">}));</span></pre>
<p>
	同时在开发期间我们想用好看的HTML页面显示异常信息时，可以设置<code>showStack</code>的值为true：
</p>
<pre class="prettyprint"><span class="pln">app</span><span class="pun">.</span><span class="kwd">use</span><span class="pun">(</span><span class="pln">express</span><span class="pun">.</span><span class="pln">errorHandler</span><span class="pun">({</span><span class="pln"> showStack</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">,</span><span class="pln"> dumpExceptions</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">true</span><span class="pln"> </span><span class="pun">}));</span></pre>
<p>
	如果请求头<code>Accept: application/json</code>，<code>errorHandler</code>中间件也能以<code>json</code>方式做出响应，这对依赖于客户端Javascript的应用开发很有益处。
</p></div></div><div class="cmd"><div class="owner"></div><a href="javascript:;" class="add-review">添加评论</a><span class="bull">•</span><a href="http://www.csser.com/user/xianlihua" title="一回">一回</a><span class="bull">•</span><span class="date" data-time="1333258825624">2012-04-01 13:40</span></div><div class="reviews"><ul class="unstyled"><li class="loading">还没有评论</li></ul><form method="post" class="form" id="form-breview-4f77ea4996ca600f78000a1f" action="/breview"><input name="bid" value="4f77ea4996ca600f78000a1f" type="hidden"><div class="control-group"><div class="controls"><textarea class="add-qreview textarea" name="review" id="review"></textarea></div></div><div class="form-actions"><input name="dosubmit" value="添加评论" class="btn btn-primary" type="submit"><a href="javascript:;" class="btn cancel">关闭</a></div></form></div></div><div class="post"><div class="post-panel"><h1><i class="icon-forward"></i> 路由参数预处理</h1><div class="post-content"><p>
	路由参数预处理通过隐式的数据处理，可以大幅提高应用代码的可读性和请求URL的验证。假如你经常性的从几个路由获取通用数据，如通过<code>/user/:id</code>加载用户信息，通常我们可能会这样做：
</p>
<pre class="prettyprint"><span class="pln">app</span><span class="pun">.</span><span class="kwd">get</span><span class="pun">(</span><span class="str">'/user/:userId'</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">req</span><span class="pun">,</span><span class="pln"> res</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">next</span><span class="pun">){</span><span class="pln">
  </span><span class="typ">User</span><span class="pun">.</span><span class="kwd">get</span><span class="pun">(</span><span class="pln">req</span><span class="pun">.</span><span class="kwd">params</span><span class="pun">.</span><span class="pln">userId</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">err</span><span class="pun">,</span><span class="pln"> user</span><span class="pun">){</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">err</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">next</span><span class="pun">(</span><span class="pln">err</span><span class="pun">);</span><span class="pln">
    res</span><span class="pun">.</span><span class="pln">send</span><span class="pun">(</span><span class="str">'user '</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> user</span><span class="pun">.</span><span class="pln">name</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">});</span><span class="pln">
</span><span class="pun">});</span></pre>
<p>
	利用预处理后参数可以被映射到回调函数，从而可以提供诸如验证、强制性改变值，甚至从数据库中加载数据等功能。下面我们将调用<code>app.param()</code>并传入我们希望映射到某个中间件的参数，可以看到我们接收了包含占位符（:userId）值的<code>id</code>参数。在这里可以与平常一样进行用户数据加载以及错误处理，并能简单的通过调用<code>next()</code>将控制权转向下一个预处理或路由（路径控制）。
</p>
<pre class="prettyprint"><span class="pln">app</span><span class="pun">.</span><span class="pln">param</span><span class="pun">(</span><span class="str">'userId'</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">req</span><span class="pun">,</span><span class="pln"> res</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">next</span><span class="pun">,</span><span class="pln"> id</span><span class="pun">){</span><span class="pln">
  </span><span class="typ">User</span><span class="pun">.</span><span class="kwd">get</span><span class="pun">(</span><span class="pln">id</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">err</span><span class="pun">,</span><span class="pln"> user</span><span class="pun">){</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">err</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">next</span><span class="pun">(</span><span class="pln">err</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">user</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">next</span><span class="pun">(</span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Error</span><span class="pun">(</span><span class="str">'failed to find user'</span><span class="pun">));</span><span class="pln">
    req</span><span class="pun">.</span><span class="pln">user </span><span class="pun">=</span><span class="pln"> user</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">next</span><span class="pun">();</span><span class="pln">
  </span><span class="pun">});</span><span class="pln">
</span><span class="pun">});</span></pre>
<p>
	这样做，不仅向上面提到的可以大幅提高路由的可读性，还能在整个应用中共享该部分的逻辑实现，达到复用目的。
</p>
<pre class="prettyprint"><span class="pln">app</span><span class="pun">.</span><span class="kwd">get</span><span class="pun">(</span><span class="str">'/user/:userId'</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">req</span><span class="pun">,</span><span class="pln"> res</span><span class="pun">){</span><span class="pln">
  res</span><span class="pun">.</span><span class="pln">send</span><span class="pun">(</span><span class="str">'CSSer用户为 '</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> req</span><span class="pun">.</span><span class="pln">user</span><span class="pun">.</span><span class="pln">name</span><span class="pun">);</span><span class="pln">
</span><span class="pun">});</span></pre>
<p>
	对于简单的情况如路由占位符验证和强迫改变值，只需要传入1个参数（支持1个参数），期间抛出的异常将自动传入<code>next(err)</code>。
</p>
<pre class="prettyprint"><span class="pln">app</span><span class="pun">.</span><span class="pln">param</span><span class="pun">(</span><span class="str">'number'</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">n</span><span class="pun">){</span><span class="pln"> </span><span class="kwd">return</span><span class="pln"> parseInt</span><span class="pun">(</span><span class="pln">n</span><span class="pun">,</span><span class="pln"> </span><span class="lit">10</span><span class="pun">);</span><span class="pln"> </span><span class="pun">});</span></pre>
<p>
	也可以同时将回调函数应用到多个占位符，比如路由<code>/commits/:from-:to</code>来说，:from和:to都是数值类型，我们可以将它们定义为数组：
</p>
<pre class="prettyprint"><span class="pln">app</span><span class="pun">.</span><span class="pln">param</span><span class="pun">([</span><span class="str">'from'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'to'</span><span class="pun">],</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">n</span><span class="pun">){</span><span class="pln"> </span><span class="kwd">return</span><span class="pln"> parseInt</span><span class="pun">(</span><span class="pln">n</span><span class="pun">,</span><span class="pln"> </span><span class="lit">10</span><span class="pun">);</span><span class="pln"> </span><span class="pun">});</span></pre></div></div><div class="cmd"><div class="owner"></div><a href="javascript:;" class="add-review">2 条评论</a><span class="bull">•</span><a href="http://www.csser.com/user/xianlihua" title="一回">一回</a><span class="bull">•</span><span class="date" data-time="1333258859993">2012-04-01 13:40</span></div><div class="reviews"><ul class="unstyled"><li class="loading">评论载入中，请稍候……</li></ul><form method="post" class="form" id="form-breview-4f77ea6bbe3baa0d78001559" action="/breview"><input name="bid" value="4f77ea6bbe3baa0d78001559" type="hidden"><div class="control-group"><div class="controls"><textarea class="add-qreview textarea" name="review" id="review"></textarea></div></div><div class="form-actions"><input name="dosubmit" value="添加评论" class="btn btn-primary" type="submit"><a href="javascript:;" class="btn cancel">关闭</a></div></form></div></div><div class="post"><div class="post-panel"><h1><i class="icon-forward"></i> 视图渲染</h1><div class="post-content"><p>
	视图的文件名默认需遵循“&lt;name&gt;.&lt;engine&gt;”的形式，这里&lt;engine&gt;是要被加载的模块的名字。比如视图<code>layout.ejs</code>就是在告诉视图系统要<code>require("ejs")</code>，被加载的模块必须输出<code>exports.compile(str, options)</code>方法，并要返回一个函数来遵守Express的模板接口约定。我们也可以使用<code>app.register()</code>来映射模板引擎到其它文件扩展名，从而实现更灵活的模板引擎行为，如此一来就可以实现“csser.html”可以被ejs引擎所渲染。
</p>
<p>
	下面我们将用<a href="http://github.com/visionmedia/jade" target="_blank">Jade</a>引擎来渲染<code>index.html</code>，因为我们没有设置<code>layout:false</code>，<code>index.jade</code>渲染后的内容将被作为<code>body</code>本地变量传入<code>layout.jade</code>。
</p>
<pre class="prettyprint"><span class="pln">app</span><span class="pun">.</span><span class="kwd">get</span><span class="pun">(</span><span class="str">'/'</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">req</span><span class="pun">,</span><span class="pln"> res</span><span class="pun">){</span><span class="pln">
    res</span><span class="pun">.</span><span class="pln">render</span><span class="pun">(</span><span class="str">'index.jade'</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> title</span><span class="pun">:</span><span class="pln"> </span><span class="str">'CSSer, 关注Web前端技术！'</span><span class="pln"> </span><span class="pun">});</span><span class="pln">
</span><span class="pun">});</span></pre>
<p>
	新增的<code>view engine</code>设置可以指定默认模板引擎，如果我们想使用jade可以这样设置：
</p>
<pre class="prettyprint"><span class="pln">app</span><span class="pun">.</span><span class="kwd">set</span><span class="pun">(</span><span class="str">'view engine'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'jade'</span><span class="pun">);</span></pre>
<p>
	于是我们就可以通过下面的方式：
</p>
<pre class="prettyprint"><span class="pln">res</span><span class="pun">.</span><span class="pln">render</span><span class="pun">(</span><span class="str">'index'</span><span class="pun">);</span></pre>
<p>
	代替如下方式:
</p>
<pre class="prettyprint"><span class="pln">res</span><span class="pun">.</span><span class="pln">render</span><span class="pun">(</span><span class="str">'index.jade'</span><span class="pun">);</span></pre>
<p>
	当<code>view engine</code>设置后，模板的扩展名就成了可选项，同时我们还可以混合匹配多模板引擎：
</p>
<pre class="prettyprint"><span class="pln">res</span><span class="pun">.</span><span class="pln">render</span><span class="pun">(</span><span class="str">'another-page.ejs'</span><span class="pun">);</span></pre>
<p>
	Express同时提供了视图选项(<code>view options</code>)设置，这些设置会在每次视图渲染后应用，比如你并不经常使用layouts，就可以这样设置：
</p>
<pre class="prettyprint"><span class="pln">app</span><span class="pun">.</span><span class="kwd">set</span><span class="pun">(</span><span class="str">'view options'</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    layout</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">false</span><span class="pln">
</span><span class="pun">});</span></pre>
<p>
	如果需要，这些设置可以在后续的<code>res.render()</code>调用中被覆盖：
</p>
<pre class="prettyprint"><span class="pln">res</span><span class="pun">.</span><span class="pln">render</span><span class="pun">(</span><span class="str">'csser-view.ejs'</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> layout</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">true</span><span class="pln"> </span><span class="pun">});</span></pre>
<p>
	可以通过指定一个路径的方式来实现用自己的layout来代替系统默认的，比如如果我们将“<code>view engine</code>”设置为<code>jade</code>并且自定义了一个名为“<code>./views/mylayout.jade</code>”的layout，我们可以这样使用它：
</p>
<pre class="prettyprint"><span class="pln">res</span><span class="pun">.</span><span class="pln">render</span><span class="pun">(</span><span class="str">'page'</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> layout</span><span class="pun">:</span><span class="pln"> </span><span class="str">'mylayout'</span><span class="pln"> </span><span class="pun">});</span></pre>
<p>
	否则必须指定扩展名：
</p>
<pre class="prettyprint"><span class="pln">res</span><span class="pun">.</span><span class="pln">render</span><span class="pun">(</span><span class="str">'page'</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> layout</span><span class="pun">:</span><span class="pln"> </span><span class="str">'mylayout.jade'</span><span class="pln"> </span><span class="pun">});</span></pre>
<p>
	这些路径也可以是绝对路径：
</p>
<pre class="prettyprint"><span class="pln">res</span><span class="pun">.</span><span class="pln">render</span><span class="pun">(</span><span class="str">'page'</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> layout</span><span class="pun">:</span><span class="pln"> __dirname </span><span class="pun">+</span><span class="pln"> </span><span class="str">'/../../mylayout.jade'</span><span class="pln"> </span><span class="pun">});</span></pre>
<p>
	这方面较好的例子就是自定义<code>ejs</code>模板的开始和关闭的标记：
</p>
<pre class="prettyprint"><span class="pln">app</span><span class="pun">.</span><span class="kwd">set</span><span class="pun">(</span><span class="str">'view options'</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    open</span><span class="pun">:</span><span class="pln"> </span><span class="str">'{{'</span><span class="pun">,</span><span class="pln">
    close</span><span class="pun">:</span><span class="pln"> </span><span class="str">'}}'</span><span class="pln">
</span><span class="pun">});</span></pre></div></div><div class="cmd"><div class="owner"></div><a href="javascript:;" class="add-review">2 条评论</a><span class="bull">•</span><a href="http://www.csser.com/user/xianlihua" title="一回">一回</a><span class="bull">•</span><span class="date" data-time="1333258901343">2012-04-01 13:41</span></div><div class="reviews"><ul class="unstyled"><li class="loading">评论载入中，请稍候……</li></ul><form method="post" class="form" id="form-breview-4f77ea9596ca600f78000a3a" action="/breview"><input name="bid" value="4f77ea9596ca600f78000a3a" type="hidden"><div class="control-group"><div class="controls"><textarea class="add-qreview textarea" name="review" id="review"></textarea></div></div><div class="form-actions"><input name="dosubmit" value="添加评论" class="btn btn-primary" type="submit"><a href="javascript:;" class="btn cancel">关闭</a></div></form></div></div><div class="post"><div class="post-panel"><h1><i class="icon-forward"></i> 局部视图</h1><div class="post-content"><p>
	Express视图系统原生支持局部和集合视图，这称作微型视图，主要用于渲染一个文档片段。比如与其在视图中循环显示评论，不如使用局部集合（partial collection）：
</p>
<pre class="prettyprint"><span class="kwd">partial</span><span class="pun">(</span><span class="str">'comment'</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> collection</span><span class="pun">:</span><span class="pln"> comments </span><span class="pun">});</span></pre>
<p>
	如果不需要其它选项或本地变量，我们可以省略对象而简单的传入评论数组，这和上面的示例是一样的：
</p>
<pre class="prettyprint"><span class="kwd">partial</span><span class="pun">(</span><span class="str">'comment'</span><span class="pun">,</span><span class="pln"> comments</span><span class="pun">);</span></pre>
<p>
	当使用局部集合时，支持一些“魔术”本地变量：
</p>
<ul>
	<li>
		<code>firstInCollection</code> 当为第一个对象时该值为true
	</li>
	<li>
		<code>indexInCollection</code> 集合中对象的索引值
	</li>
	<li>
		<code>lastInCollection</code> 当为最后一个对象时为true
	</li>
	<li>
		<code>collectionLength</code> 集合的长度
	</li>
</ul>
<p>
	传入（或生成）的本地变量优先，但传入父视图的本地变量在子视图仍有效。因此如果我们用<code>partial(‘blog/post’, post)</code>来渲染博客日志时，将生成<code>post</code>的本地变量，但调用本函数的视图拥有本地<code>用户</code>，它在<code>blog/post</code>视图依然有效。
</p>
<p>
	性能提示：当使用局部集合渲染100长度的数组就意味着需要渲染100次视图，对于简单的集合你可以将循环内联，而不要使用局部集合，这样可以减少系统开销。
</p></div></div><div class="cmd"><div class="owner"></div><a href="javascript:;" class="add-review">添加评论</a><span class="bull">•</span><a href="http://www.csser.com/user/xianlihua" title="一回">一回</a><span class="bull">•</span><span class="date" data-time="1333258939336">2012-04-01 13:42</span></div><div class="reviews"><ul class="unstyled"><li class="loading">还没有评论</li></ul><form method="post" class="form" id="form-breview-4f77eabbbe3baa0d780015a2" action="/breview"><input name="bid" value="4f77eabbbe3baa0d780015a2" type="hidden"><div class="control-group"><div class="controls"><textarea class="add-qreview textarea" name="review" id="review"></textarea></div></div><div class="form-actions"><input name="dosubmit" value="添加评论" class="btn btn-primary" type="submit"><a href="javascript:;" class="btn cancel">关闭</a></div></form></div></div><div class="post"><div class="post-panel"><h1><i class="icon-forward"></i> 视图查找</h1><div class="post-content"><p>
	视图查找是相对于父视图进行的，比如我们有一个名为“<code>views/user/list.jade</code>”的页面视图，如果在该视图中调用<code>partial(‘edit’)</code>，视图系统将会尝试查找并加载“<code>views/user/edit.jade</code>”，而<code>partial(‘../messages’)</code>将加载“<code>views/messages.jade</code>”。
</p>
<p>
	视图系统还支持索引模板，这样你就可以使用一个同名的目录。比如，在一个路由中我们执行<code>res.render(‘users’)</code>，这将指向“<code>views/users.jade</code>”或者“<code>views/users/index.jade</code>”。
</p>
<p>
	当使用上面的索引视图时，我们可以通过<code>partial(‘users’)</code>从同名目录下引用“<code>views/users/index.jade</code>”，同时视图系统会尝试“<code>../users/index</code>”，这能减少我们调用<code>partial(‘index’)</code>的需要。
</p></div></div><div class="cmd"><div class="owner"></div><a href="javascript:;" class="add-review">添加评论</a><span class="bull">•</span><a href="http://www.csser.com/user/xianlihua" title="一回">一回</a><span class="bull">•</span><span class="date" data-time="1333258970758">2012-04-01 13:42</span></div><div class="reviews"><ul class="unstyled"><li class="loading">还没有评论</li></ul><form method="post" class="form" id="form-breview-4f77eadabe3baa0d780015bd" action="/breview"><input name="bid" value="4f77eadabe3baa0d780015bd" type="hidden"><div class="control-group"><div class="controls"><textarea class="add-qreview textarea" name="review" id="review"></textarea></div></div><div class="form-actions"><input name="dosubmit" value="添加评论" class="btn btn-primary" type="submit"><a href="javascript:;" class="btn cancel">关闭</a></div></form></div></div><div class="post"><div class="post-panel"><h1><i class="icon-forward"></i> 模板引擎</h1><div class="post-content"><p>
	Express支持许多模板引擎，常用的有：
</p>
<ul>
	<li>
		<a href="http://github.com/visionmedia/haml.js" target="_blank">Haml</a> haml 的实现
	</li>
	<li>
		<a href="http://jade-lang.com/" target="_blank">Jade</a> haml.js 接替者，同时也是Express的默认模板引擎
	</li>
	<li>
		<a href="http://github.com/visionmedia/ejs" target="_blank">EJS</a> 嵌入JavaScript模板
	</li>
	<li>
		<a href="http://github.com/mauricemach/coffeekup" target="_blank">CoffeeKup</a> 基于CoffeeScript的模板引擎
	</li>
	<li>
		<a href="https://github.com/kof/node-jqtpl" target="_blank">jQuery Templates</a> 的NodeJS版本
	</li>
</ul></div></div><div class="cmd"><div class="owner"></div><a href="javascript:;" class="add-review">添加评论</a><span class="bull">•</span><a href="http://www.csser.com/user/xianlihua" title="一回">一回</a><span class="bull">•</span><span class="date" data-time="1333259007575">2012-04-01 13:43</span></div><div class="reviews"><ul class="unstyled"><li class="loading">还没有评论</li></ul><form method="post" class="form" id="form-breview-4f77eaffbe3baa0d780015d9" action="/breview"><input name="bid" value="4f77eaffbe3baa0d780015d9" type="hidden"><div class="control-group"><div class="controls"><textarea class="add-qreview textarea" name="review" id="review"></textarea></div></div><div class="form-actions"><input name="dosubmit" value="添加评论" class="btn btn-primary" type="submit"><a href="javascript:;" class="btn cancel">关闭</a></div></form></div></div><div class="post"><div class="post-panel"><h1><i class="icon-forward"></i> Session Support</h1><div class="post-content"><p>
	可以在Express中通过增加Connect的<code>session</code>中间件来开启Session支持，当然前提是需要在这之前使用<code>cookieParser</code>中间件，用于分析和处理<code>req.cookies</code>的cookie数据(我们知道session会利用cookie进行通信保持的)。
</p>
<pre class="prettyprint"><span class="pln">app</span><span class="pun">.</span><span class="kwd">use</span><span class="pun">(</span><span class="pln">express</span><span class="pun">.</span><span class="pln">cookieParser</span><span class="pun">());</span><span class="pln">
app</span><span class="pun">.</span><span class="kwd">use</span><span class="pun">(</span><span class="pln">express</span><span class="pun">.</span><span class="pln">session</span><span class="pun">({</span><span class="pln"> secret</span><span class="pun">:</span><span class="pln"> </span><span class="str">"keyboard cat"</span><span class="pln"> </span><span class="pun">}));</span></pre>
<p>
	默认<code>session</code>中间件使用Connect绑定的内存存储，但也有另外的实现方式。比如<a href="http://github.com/visionmedia/connect-redis" target="_blank">connect-redis</a>就提供了一个<a href="http://code.google.com/p/redis/" target="_blank">Redis</a>的session存储方案：
</p>
<pre class="prettyprint"><span class="kwd">var</span><span class="pln"> </span><span class="typ">RedisStore</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">require</span><span class="pun">(</span><span class="str">'connect-redis'</span><span class="pun">);</span><span class="pln">
app</span><span class="pun">.</span><span class="kwd">use</span><span class="pun">(</span><span class="pln">express</span><span class="pun">.</span><span class="pln">cookieParser</span><span class="pun">());</span><span class="pln">
app</span><span class="pun">.</span><span class="kwd">use</span><span class="pun">(</span><span class="pln">express</span><span class="pun">.</span><span class="pln">session</span><span class="pun">({</span><span class="pln"> secret</span><span class="pun">:</span><span class="pln"> </span><span class="str">"CSSer加密字符串"</span><span class="pun">,</span><span class="pln"> store</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">RedisStore</span><span class="pln"> </span><span class="pun">}));</span></pre>
<p>
	现在<code>req.session</code>和<code>req.sessionStore</code>属性就可以被所有路由及下级中间件所访问，<code>req.session</code>的属性会伴随着每一次响应发送给客户端，下面是一个购物车的例子：
</p>
<pre class="prettyprint"><span class="kwd">var</span><span class="pln"> </span><span class="typ">RedisStore</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">require</span><span class="pun">(</span><span class="str">'connect-redis'</span><span class="pun">);</span><span class="pln">
app</span><span class="pun">.</span><span class="kwd">use</span><span class="pun">(</span><span class="pln">express</span><span class="pun">.</span><span class="pln">bodyParser</span><span class="pun">());</span><span class="pln">
app</span><span class="pun">.</span><span class="kwd">use</span><span class="pun">(</span><span class="pln">express</span><span class="pun">.</span><span class="pln">cookieParser</span><span class="pun">());</span><span class="pln">
app</span><span class="pun">.</span><span class="kwd">use</span><span class="pun">(</span><span class="pln">express</span><span class="pun">.</span><span class="pln">session</span><span class="pun">({</span><span class="pln"> secret</span><span class="pun">:</span><span class="pln"> </span><span class="str">"keyboard cat"</span><span class="pun">,</span><span class="pln"> store</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">RedisStore</span><span class="pln"> </span><span class="pun">}));</span><span class="pln">

app</span><span class="pun">.</span><span class="pln">post</span><span class="pun">(</span><span class="str">'/add-to-cart'</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">req</span><span class="pun">,</span><span class="pln"> res</span><span class="pun">){</span><span class="pln">
  </span><span class="com">// 利用bodyParser()中间件处理POST提交的表单数据</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> items </span><span class="pun">=</span><span class="pln"> req</span><span class="pun">.</span><span class="pln">body</span><span class="pun">.</span><span class="pln">items</span><span class="pun">;</span><span class="pln">
  req</span><span class="pun">.</span><span class="pln">session</span><span class="pun">.</span><span class="pln">items </span><span class="pun">=</span><span class="pln"> items</span><span class="pun">;</span><span class="pln">
  res</span><span class="pun">.</span><span class="pln">redirect</span><span class="pun">(</span><span class="str">'back'</span><span class="pun">);</span><span class="pln">
</span><span class="pun">});</span><span class="pln">

app</span><span class="pun">.</span><span class="kwd">get</span><span class="pun">(</span><span class="str">'/add-to-cart'</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">req</span><span class="pun">,</span><span class="pln"> res</span><span class="pun">){</span><span class="pln">
  </span><span class="com">// 当页面回到返回并通过GET请求/add-to-cart 时</span><span class="pln">
  </span><span class="com">// 我们可以检查req.session.items &amp;&amp; req.session.items.length，然后将信息打印到页面</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">req</span><span class="pun">.</span><span class="pln">session</span><span class="pun">.</span><span class="pln">items </span><span class="pun">&amp;&amp;</span><span class="pln"> req</span><span class="pun">.</span><span class="pln">session</span><span class="pun">.</span><span class="pln">items</span><span class="pun">.</span><span class="pln">length</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    req</span><span class="pun">.</span><span class="pln">flash</span><span class="pun">(</span><span class="str">'info'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'You have %s items in your cart'</span><span class="pun">,</span><span class="pln"> req</span><span class="pun">.</span><span class="pln">session</span><span class="pun">.</span><span class="pln">items</span><span class="pun">.</span><span class="pln">length</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  res</span><span class="pun">.</span><span class="pln">render</span><span class="pun">(</span><span class="str">'shopping-cart'</span><span class="pun">);</span><span class="pln">
</span><span class="pun">});</span></pre>
<p>
	<code>req.session</code>对象还拥有许多其它方法，如<code>Session#touch()</code>, <code>Session#destroy()</code>, <code>Session#regenerate()</code>等用于session处理，更多信息请查看<a href="http://senchalabs.github.com/connect/middleware-session.html" target="_blank">Connect Session文档</a>。
</p></div></div><div class="cmd"><div class="owner"></div><a href="javascript:;" class="add-review">14 条评论</a><span class="bull">•</span><a href="http://www.csser.com/user/xianlihua" title="一回">一回</a><span class="bull">•</span><span class="date" data-time="1333259052621">2012-04-01 13:44</span></div><div class="reviews"><ul class="unstyled"><li class="loading">评论载入中，请稍候……</li></ul><form method="post" class="form" id="form-breview-4f77eb2cbe3baa0d780015f4" action="/breview"><input name="bid" value="4f77eb2cbe3baa0d780015f4" type="hidden"><div class="control-group"><div class="controls"><textarea class="add-qreview textarea" name="review" id="review"></textarea></div></div><div class="form-actions"><input name="dosubmit" value="添加评论" class="btn btn-primary" type="submit"><a href="javascript:;" class="btn cancel">关闭</a></div></form></div></div></div></div></div><div class="span4"><div class="mod list"><h2>相似内容</h2><ul class="unstyled"><li><a href="http://www.csser.com/board/4f55035305ee2e572400005e" title="NodeJS 常用模块介绍"><i class="icon-book"></i> NodeJS 常用模块介绍</a></li><li><a href="http://www.csser.com/board/4f3f516e38a5ebc9780004fe" title="Mongoose - 让NodeJS更容易操作Mongodb数据库"><i class="icon-book"></i> Mongoose - 让NodeJS更容易操作Mongodb数据库</a></li><li><a href="http://www.csser.com/board/4f3f516e38a5ebc978000512" title="Mongoose 定义模型"><i class="icon-book"></i> Mongoose 定义模型</a></li><li><a href="http://www.csser.com/board/4f45dd056023a6fe7f000a98" title="NodeJS教程--基于ExpressJS框架的文件上传"><i class="icon-book"></i> NodeJS教程--基于ExpressJS框架的文件上传</a></li><li><a href="http://www.csser.com/board/4f3f516e38a5ebc978000508" title="Jade模板引擎入门教程"><i class="icon-book"></i> Jade模板引擎入门教程</a></li><li><a href="http://www.csser.com/board/4f4e92dbeb0defac5700011e" title="Mongoose 基本功能使用"><i class="icon-book"></i> Mongoose 基本功能使用</a></li><li><a href="http://www.csser.com/question/4fcd0604a5a685b83700120f" title="express.static的作用是什么？"><i class="icon-comment"></i> express.static的作用是什么？</a></li><li><a href="http://www.csser.com/board/4fe7f74bb3258cf278000768" title="用 Express 和 MongoDB 寫一個 todo list"><i class="icon-book"></i> 用 Express 和 MongoDB 寫一個 todo list</a></li><li><a href="http://www.csser.com/board/4f3f516e38a5ebc978000501" title="NodeJS框架express的路径映射（路由）功能及控制"><i class="icon-book"></i> NodeJS框架express的路径映射（路由）功能及控制</a></li><li><a href="http://www.csser.com/board/4f3f516e38a5ebc978000503" title="NodeJS框架express的HTTP方法和错误处理"><i class="icon-book"></i> NodeJS框架express的HTTP方法和错误处理</a></li></ul></div><div class="mod list subnav"><h2 style="padding-bottom:0;">贴板目录</h2><ul class="unstyled"><li><a href="#/post/4f77e772be3baa0d78001470">express 的安装</a></li><li><a href="#/post/4f77e82696ca600f7800097f">创建服务器</a></li><li><a href="#/post/4f77e88196ca600f78000985">创建 HTTPS 服务器</a></li><li><a href="#/post/4f77e8db96ca600f780009f3">配置</a></li><li><a href="#/post/4f77e914be3baa0d780014bf">设置</a></li><li><a href="#/post/4f77e94896ca600f780009f8">路由</a></li><li><a href="#/post/4f77e98196ca600f780009fd">路由控制</a></li><li><a href="#/post/4f77e9a996ca600f78000a02">中间件</a></li><li><a href="#/post/4f77e9dcbe3baa0d78001521">路由中间件</a></li><li><a href="#/post/4f77ea1cbe3baa0d7800153c">HTTP 方法</a></li><li><a href="#/post/4f77ea4996ca600f78000a1f">错误处理</a></li><li><a href="#/post/4f77ea6bbe3baa0d78001559">路由参数预处理</a></li><li><a href="#/post/4f77ea9596ca600f78000a3a">视图渲染</a></li><li><a href="#/post/4f77eabbbe3baa0d780015a2">局部视图</a></li><li><a href="#/post/4f77eadabe3baa0d780015bd">视图查找</a></li><li><a href="#/post/4f77eaffbe3baa0d780015d9">模板引擎</a></li><li><a href="#/post/4f77eb2cbe3baa0d780015f4">Session Support</a></li></ul></div></div></div><script>var BID = '4f77e6f996ca600f78000936', POSTS = [{"_id":"4f77e772be3baa0d78001470","board":"4f77e6f996ca600f78000936","content":"<pre class=\"prettyprint\" >$ npm install express</pre>\r\n<p>\r\n\t或者\r\n</p>\r\n<p>\r\n<pre class=\"prettyprint\" >$ npm install -g express</pre>\r\n</p>","create_date":"2012-04-01T05:28:18.995Z","diff":0,"down_num":0,"favorite_num":0,"favorites":[],"info":" [代码]   或者     [代码]   ","last_modify_date":"2012-04-01T05:28:18.995Z","review_num":3,"title":"express 的安装","up_num":0,"ups":[],"user":{"_id":"4f3f4d9469cd2e1f78000001","avatar":"http://s1.csser.com/b6dd557640afdf49d0959f419678bda0-25.png","domain":"xianlihua","username":"一回"},"dateTime":1333258098995,"dateText":"2012-04-01 13:28","imdowner":false,"imfavoriter":false},{"_id":"4f77e82696ca600f7800097f","board":"4f77e6f996ca600f78000936","content":"<p>\r\n\t要创建 <code>express.HTTPServer</code> 的实例，只需简单的调用 <code>createServer()</code> 方法即可。通过 <code>HTTPServer</code> 实例 <code>app</code> 我们可以定义基于 HTTP 动作（HTTP verbs）的路由（routes），本例中为 <code>app.get()</code>。\r\n</p>\r\n<pre>var app = require('express').createServer();\n\napp.get('/', function(req, res){\r\n  res.send('hello world from csser.com!');\r\n});\n\napp.listen(3000);\r\n</pre>","create_date":"2012-04-01T05:31:18.457Z","diff":0,"down_num":0,"favorite_num":0,"favorites":[],"info":"  要创建  express.HTTPServer  的实例，只需简单的调用  createServer()  方法即可。通过  HTTPServer  实例  app  我们可以定义基于 HTTP 动作（HTTP verbs）的路由（routes），本例中为  app.get() 。   [代码]  ","last_modify_date":"2012-04-01T05:31:18.458Z","review_num":5,"title":"创建服务器","up_num":0,"ups":[],"user":{"_id":"4f3f4d9469cd2e1f78000001","avatar":"http://s1.csser.com/b6dd557640afdf49d0959f419678bda0-25.png","domain":"xianlihua","username":"一回"},"dateTime":1333258278457,"dateText":"2012-04-01 13:31","imdowner":false,"imfavoriter":false},{"content":"<p>\r\n\t要初始化一个<code>express.HTTPSServer</code>实例，与上例相似，不同的是在<code>createServer</code>方法我们传入一个对象作为配置参数，该对象接受 <code>key</code>， <code>cert</code> 和其它在<a href=\"http://nodejs.org/docs/v0.4.6/api/https.html#https.createServer\" target=\"_blank\">NodeJS https文档</a>中提到的配置参数。\r\n</p>\r\n<pre> var app = require('express').createServer({ key: ... });\r\n</pre>","info":"  要初始化一个 express.HTTPSServer 实例，与上例相似，不同的是在 createServer 方法我们传入一个对象作为配置参数，该对象接受  key ，  cert  和其它在 NodeJS https文档 中提到的配置参数。   [代码]  ","user":{"_id":"4f3f4d9469cd2e1f78000001","avatar":"http://s1.csser.com/b6dd557640afdf49d0959f419678bda0-25.png","domain":"xianlihua","username":"一回"},"title":"创建 HTTPS 服务器","board":"4f77e6f996ca600f78000936","_id":"4f77e88196ca600f78000985","diff":0,"down_num":0,"ups":[],"up_num":0,"favorites":[],"favorite_num":0,"review_num":0,"last_modify_date":"2012-04-01T05:32:49.150Z","create_date":"2012-04-01T05:32:49.150Z","dateTime":1333258369150,"dateText":"2012-04-01 13:32","imdowner":false,"imfavoriter":false},{"_id":"4f77e8db96ca600f780009f3","board":"4f77e6f996ca600f78000936","content":"<p>\r\n\tExpress支持多工作环境，比如<code>生产环境</code>和<code>开发环境</code>等。开发者可以使用<code>configure()</code>方法根据当前环境的需要进行设置，当<code>configure()</code>没有传入环境名称时，它会在各环境之前被调用（一回注：相当于被各个明确环境所共享）。\r\n</p>\r\n<p>\r\n\t下面的示例我们只抛出异常（<code>dumpException</code>），并且在<code>开发模式</code>对异常堆栈的输出做出响应，但是不论对开发或者生产环境我们都使用了<code>methodOverride</code>和<code>bodyParser</code>。特别注意对<code>app.router</code>的使用，它可以被用来设置应用的<code>路由</code>（可选），否则首次对<code>app.get()</code>、<code>app.post()</code>等的调用会设置路由。\r\n</p>\r\n<pre>// 定义共享环境\r\napp.configure(function(){\r\n    app.use(express.methodOverride());\r\n    app.use(express.bodyParser());\r\n    app.use(app.router);\r\n});\n\n// 定义开发环境\r\napp.configure('development', function(){\r\n    app.use(express.static(__dirname + '/public'));\r\n    app.use(express.errorHandler({ dumpExceptions: true, showStack: true }));\r\n});\n\n// 定义生产环境\r\napp.configure('production', function(){\r\n    var oneYear = 31557600000;\r\n    app.use(express.static(__dirname + '/public', { maxAge: oneYear }));\r\n    app.use(express.errorHandler());\r\n});\r\n</pre>\r\n<p>\r\n\t对于内部和多重设置（internal和arbitrary），Express提供了 <code>set(key[, val])</code>, <code>enable(key)</code>, <code>disable(key)</code>等方法：\r\n</p>\r\n<pre>app.configure(function(){\r\n   app.set('views', __dirname + '/views');\r\n   app.set('views');\r\n   // =&gt; \"/absolute/path/to/views\"\n\n   app.enable('some feature');\r\n   // 与 app.set('some feature', true); 相同\n\n   app.disable('some feature');\r\n   // 与 app.set('some feature', false); 相同\n\n   app.enabled('some feature')\r\n   // =&gt; false\r\n});\r\n</pre>\r\n<p>\r\n\t要修改环境，可以通过设置<code>NODE_ENV</code>环境变量来实现，例如：\r\n</p>\r\n<pre>$ NODE_ENV=production node app.js\r\n</pre>\r\n<p>\r\n\t这很<code>重要</code>，因为许多的缓存机制只有在生产环境<code>才会启用</code>。\r\n</p>","create_date":"2012-04-01T05:34:19.960Z","diff":0,"down_num":0,"favorite_num":0,"favorites":[],"info":"  Express支持多工作环境，比如 生产环境 和 开发环境 等。开发者可以使用 configure() 方法根据当前环境的需要进行设置，当 configure() 没有传入环境名称时，它会在各环境之前被调用（一回注：相当于被各个明确环境所共享）。     下面的示例我们只抛出异常（ dumpException ），并且在 开发模式 对异常堆栈的输出做出响应，但是不论对开发或者生产环境我们都使用 ","last_modify_date":"2012-04-01T05:34:19.960Z","review_num":7,"title":"配置","up_num":0,"ups":[],"user":{"_id":"4f3f4d9469cd2e1f78000001","avatar":"http://s1.csser.com/b6dd557640afdf49d0959f419678bda0-25.png","domain":"xianlihua","username":"一回"},"dateTime":1333258459960,"dateText":"2012-04-01 13:34","imdowner":false,"imfavoriter":false},{"_id":"4f77e914be3baa0d780014bf","board":"4f77e6f996ca600f78000936","content":"<p>\r\n\tExpress 支持以下设置项：\r\n</p>\r\n<ul>\r\n\t<li>\r\n\t\thome为res.redirect()提供应用的基准路径，透明的处理已安装的应用。\r\n\t</li>\r\n\t<li>\r\n\t\tviews视图（views）层的根目录，默认指向CWD/views\r\n\t</li>\r\n\t<li>\r\n\t\tview engine默认的视图（view）引擎的名字，不包含扩展名。\r\n\t</li>\r\n\t<li>\r\n\t\tview options用于设置全局视图选项的对象\r\n\t</li>\r\n</ul>","create_date":"2012-04-01T05:35:16.070Z","diff":0,"down_num":0,"favorite_num":0,"favorites":[],"info":"  Express 支持以下设置项：       home为res.redirect()提供应用的基准路径，透明的处理已安装的应用。     views视图（views）层的根目录，默认指向CWD/views     view engine默认的视图（view）引擎的名字，不包含扩展名。     view options用于设置全局视图选项的对象     ","last_modify_date":"2012-04-01T05:35:16.070Z","review_num":2,"title":"设置","up_num":0,"ups":[],"user":{"_id":"4f3f4d9469cd2e1f78000001","avatar":"http://s1.csser.com/b6dd557640afdf49d0959f419678bda0-25.png","domain":"xianlihua","username":"一回"},"dateTime":1333258516070,"dateText":"2012-04-01 13:35","imdowner":false,"imfavoriter":false},{"_id":"4f77e94896ca600f780009f8","board":"4f77e6f996ca600f78000936","content":"<p>\r\n\tExpress利用HTTP动作提供了有意义并富有表现力的URL映射API，例如我们可能想让用户帐号的URL看起来像<code>/user/12</code>的样子，下面的例子就能实现这样的路由，其中与占位标识符（本例为:id）相关的值可以被<code>req.params</code>获取到。\r\n</p>\r\n<pre>app.get('/user/:id', function(req, res){\r\n    res.send('user ' + req.params.id);\r\n});\r\n</pre>\r\n<p>\r\n\t上例中当我们访问<code>/user/12</code>时返回“user 12”, csser注：app.get相当于在服务器注册了一个监听get请求事件的侦听器，当请求的URL满足第一个参数时，执行后面的回调函数，该过程是异步的。\r\n</p>\r\n<p>\r\n\t路由是一个可以被内部<code>编译</code>成<code>正则表达式</code>的简单字符串，比如当<code>/user/:id</code>被编译后，被内部编译后的正则表达式字符串看起来会是下面的样子（简化后）：\r\n</p>\r\n<pre>\\/user\\/([^\\/]+)\\/?\r\n</pre>\r\n<p>\r\n\t要实现复杂点的，我们可以传入正则表达式直接量，因为正则捕获组是匿名的因此我们可以通过<code>req.params</code>进行访问，第一个捕获组应该是<code>req.params[0]</code>，第二个应该是<code>req.params[1]</code>，以此类推。\r\n</p>\r\n<pre>app.get(/^\\/users?(?:\\/(\\d+)(?:\\.\\.(\\d+))?)?/, function(req, res){\r\n    res.send(req.params);\r\n});\r\n</pre>\r\n<p>\r\n\t通过Linux的curl命令来测试我们定义的路由：\r\n</p>\r\n<pre>$ curl http://cssercom:3000/user\r\n[null,null]\r\n$ curl http://cssercom:3000/users\r\n[null,null]\r\n$ curl http://cssercom:3000/users/1\r\n[\"1\",null]\r\n$ curl http://cssercom:3000/users/1..15\r\n[\"1\",\"15\"]\r\n</pre>\r\n<p>\r\n\t下面是一些路由例子，以及与之相匹配的关联路径：\r\n</p>\r\n<pre> \"/user/:id\"\r\n/user/12\n\n\"/users/:id?\"\r\n/users/5\r\n/users\n\n\"/files/*\"\r\n/files/jquery.js\r\n/files/javascripts/jquery.js\n\n\"/file/*.*\"\r\n/files/jquery.js\r\n/files/javascripts/jquery.js\n\n\"/user/:id/:operation?\"\r\n/user/1\r\n/user/1/edit\n\n\"/products.:format\"\r\n/products.json\r\n/products.xml\n\n\"/products.:format?\"\r\n/products.json\r\n/products.xml\r\n/products\n\n\"/user/:id.:format?\"\r\n/user/12\r\n/user/12.json\r\n</pre>\r\n<p>\r\n\t另外，我们可以通过<code>POST</code>方式提交json数据，然后利用<code>bodyParser</code>中间件解析json请求体并把json数据返回给客户端：\r\n</p>\r\n<pre>var express = require('express')\r\n  , app = express.createServer();\n\napp.use(express.bodyParser());\n\napp.post('/', function(req, res){\r\n  res.send(req.body);\r\n});\n\napp.listen(3000);\r\n</pre>\r\n<p>\r\n\t通常我们所使用的占位符（比如/user/:id）都没有任何限制，即用户可以传入各种各样数据类型的id值，如果我们希望限制用户id为数字，可以这样写<code>“/user/:id(\\d+)”</code>，这样就能保证只有该占位符数据类型为数值类型才会进行路由的相关处理。\r\n</p>","create_date":"2012-04-01T05:36:08.038Z","diff":0,"down_num":0,"favorite_num":0,"favorites":[],"info":"  Express利用HTTP动作提供了有意义并富有表现力的URL映射API，例如我们可能想让用户帐号的URL看起来像 /user/12 的样子，下面的例子就能实现这样的路由，其中与占位标识符（本例为:id）相关的值可以被 req.params 获取到。   [代码]   上例中当我们访问 /user/12 时返回“user 12”, csser注：app.get相当于在服务器注册了一个监听get ","last_modify_date":"2012-04-28T02:47:03.241Z","review_num":4,"title":"路由","up_num":0,"ups":[],"user":{"_id":"4f3f4d9469cd2e1f78000001","avatar":"http://s1.csser.com/b6dd557640afdf49d0959f419678bda0-25.png","domain":"xianlihua","username":"一回"},"dateTime":1333258568038,"dateText":"2012-04-01 13:36","imdowner":false,"imfavoriter":false},{"_id":"4f77e98196ca600f780009fd","board":"4f77e6f996ca600f78000936","content":"<p>\r\n\t一个应用中可以定义多个路由，我们可以控制以令其转向下一个路由，Express提供了第<code>三</code>个参数即<code>next()</code>函数。当一个模式不被匹配时，控制将被转回Connect（Express基于Connect模块），同时中间件会继续按照它们在<code>use()</code>中增加的顺序来执行。当多个定义的路由都可能匹配同一个URL时也是如此，除非某个路由并不调用<code>next()</code>且已将响应输出到客户端，否则它们也将按顺序执行。\r\n</p>\r\n<pre>app.get('/users/:id?', function(req, res, next){\r\n    var id = req.params.id;\r\n    if (id) {\r\n        // 一回注：如果在这里就将响应内容输出给客户端，那么后续的URL映射将不会被调用\r\n    } else {\r\n        next(); // 将控制转向下一个符合URL的路由\r\n    }\r\n});\n\napp.get('/users', function(req, res){\r\n    // do something else\r\n});\r\n</pre>\r\n<p>\r\n\t<code>app.all()</code>方法可以对所有HTTP动作应用单一调用入口，这在有些情况下很有用。下面我们使用该功能来从我们的模拟数据库中加载一个用户，并把它分配给<code>req.user</code>。\r\n</p>\r\n<pre>var express = require('express')\r\n  , app = express.createServer();\n\nvar users = [{ name: 'www.csser.com' }];\n\napp.all('/user/:id/:op?', function(req, res, next){\r\n  req.user = users[req.params.id];\r\n  if (req.user) {\r\n    next();\r\n  } else {\r\n    next(new Error('cannot find user ' + req.params.id));\r\n  }\r\n});\n\napp.get('/user/:id', function(req, res){\r\n  res.send('viewing ' + req.user.name);\r\n});\n\napp.get('/user/:id/edit', function(req, res){\r\n  res.send('editing ' + req.user.name);\r\n});\n\napp.put('/user/:id', function(req, res){\r\n  res.send('updating ' + req.user.name);\r\n});\n\napp.get('*', function(req, res){\r\n  res.send('what???', 404);\r\n});\n\napp.listen(3000);\r\n</pre>","create_date":"2012-04-01T05:37:05.771Z","diff":0,"down_num":0,"favorite_num":0,"favorites":[],"info":"  一个应用中可以定义多个路由，我们可以控制以令其转向下一个路由，Express提供了第 三 个参数即 next() 函数。当一个模式不被匹配时，控制将被转回Connect（Express基于Connect模块），同时中间件会继续按照它们在 use() 中增加的顺序来执行。当多个定义的路由都可能匹配同一个URL时也是如此，除非某个路由并不调用 next() 且已将响应输出到客户端，否则它们也将按顺 ","last_modify_date":"2012-04-01T05:37:05.771Z","review_num":1,"title":"路由控制","up_num":0,"ups":[],"user":{"_id":"4f3f4d9469cd2e1f78000001","avatar":"http://s1.csser.com/b6dd557640afdf49d0959f419678bda0-25.png","domain":"xianlihua","username":"一回"},"dateTime":1333258625771,"dateText":"2012-04-01 13:37","imdowner":false,"imfavoriter":false},{"_id":"4f77e9a996ca600f78000a02","board":"4f77e6f996ca600f78000936","content":"<p>\r\n\t中间件可以通过<a href=\"http://github.com/senchalabs/connect\" target=\"_blank\">Connect</a>传入<code>express.createServer()</code>，就像正常的连接服务器一样，比如：\r\n</p>\r\n<pre>var express = require('express');\n\nvar app = express.createServer(\r\n    express.logger(),\r\n    express.bodyParser()\r\n);\r\n</pre>\r\n<p>\r\n\t另外，在<code>configure()</code>函数块中利用<code>use()</code>函数增加中间件，也是一种很好的方式。\r\n</p>\r\n<pre>app.use(express.logger({ format: ':method :uri' }));\r\n</pre>\r\n<p>\r\n\t通常连接中间件可以通过<code>require(\"connect\")</code>的方式，如：\r\n</p>\r\n<pre>var connect = require('connect');\r\napp.use(connect.logger());\r\napp.use(connect.bodyParser());\r\n</pre>\r\n<p>\r\n\t这让人感觉有些不太爽，于是express重新输出了（re-exports)这些中间件属性，但是在使用上保持了<code>一致性</code>：\r\n</p>\r\n<pre>app.use(express.logger());\r\napp.use(express.bodyParser());\r\n</pre>","create_date":"2012-04-01T05:37:45.996Z","diff":0,"down_num":0,"favorite_num":0,"favorites":[],"info":"  中间件可以通过 Connect 传入 express.createServer() ，就像正常的连接服务器一样，比如：   [代码]   另外，在 configure() 函数块中利用 use() 函数增加中间件，也是一种很好的方式。   [代码]   通常连接中间件可以通过 require(\"connect\") 的方式，如：   [代码]   这让人感觉有些不太爽，于是express重新输出 ","last_modify_date":"2012-04-01T05:37:45.996Z","review_num":8,"title":"中间件","up_num":0,"ups":[],"user":{"_id":"4f3f4d9469cd2e1f78000001","avatar":"http://s1.csser.com/b6dd557640afdf49d0959f419678bda0-25.png","domain":"xianlihua","username":"一回"},"dateTime":1333258665996,"dateText":"2012-04-01 13:37","imdowner":false,"imfavoriter":false},{"_id":"4f77e9dcbe3baa0d78001521","board":"4f77e6f996ca600f78000936","content":"<p>\r\n\t这里路径映射也可以理解为路由的意思，路由通过传入一个或多个附加的回调函数（或数组）到方法中，从而可以利用特定路由的中间件。该功能对限制访问以及加载路由使用的数据非常有用。\r\n</p>\r\n<p>\r\n\t通常情况下异步数据的查询看起来像下面的样子，这里我们使用<code>:id</code>参数，并尝试获取一个用户。\r\n</p>\r\n<pre>app.get('/user/:id', function(req, res, next){\r\n  loadUser(req.params.id, function(err, user){\r\n    if (err) return next(err);\r\n    res.send('Viewing user of csser.com ' + user.name);\r\n  });\r\n});\r\n</pre>\r\n<p>\r\n\t为了保持代码整洁并且提高可读性，我们可以在中间件内部应用该逻辑。正如你所看到的，将逻辑抽象到中间件里让我们达到一定程度的复用，同时代码更干净。\r\n</p>\r\n<pre>function loadUser(req, res, next) {\r\n  // 这里提供假数据，你可以从数据库中获取真实用户信息\r\n  var user = users[req.params.id];\r\n  if (user) {\r\n    req.user = user;\r\n    next();\r\n  } else {\r\n    next(new Error('不存在的用户 ' + req.params.id));\r\n  }\r\n}\n\napp.get('/user/:id', loadUser, function(req, res){\r\n  res.send('正在查看用户 ' + req.user.name);\r\n});\r\n</pre>\r\n<p>\r\n\t一回注：看到了吗？上面的路径映射的回调函数参数是可以支持多个的。\r\n</p>\r\n<p>\r\n\t多重路由中间件可以被按照顺序来执行，从而可以实现更复杂的逻辑，比如限制访问某个用户的访问权限，下面的代码将只允许认证用户才可以编辑其帐号信息。\r\n</p>\r\n<pre>function andRestrictToSelf(req, res, next) {\r\n  req.authenticatedUser.id == req.user.id\r\n    ? next()\r\n    : next(new Error('无权限'));\n\n}\n\napp.get('/user/:id/edit', loadUser, andRestrictToSelf, function(req, res){\r\n  res.send('开始编辑用户 ' + req.user.name);\r\n});\r\n</pre>\r\n<p>\r\n\t请记住中间件是简单的函数，我们还能定义<code>返回</code>中间件的函数，从而可以创建一个更有表现力和更易用的如下方案：\r\n</p>\r\n<pre>function andRestrictTo(role) {\r\n  return function(req, res, next) {\r\n    req.authenticatedUser.role == role\r\n      ? next()\r\n      : next(new Error('无权限'));\n\n  }\r\n}\n\napp.del('/user/:id', loadUser, andRestrictTo('admin'), function(req, res){\r\n  res.send('已删除用户 ' + req.user.name);\r\n});\r\n</pre>\r\n<p>\r\n\t一回注：app.del的第三个参数之所以可以这样写，是因为其返回的是一个函数，而该函数可以访问’admin’的值，这里涉及到闭包的概念，如有疑问请在CSSer.com查找闭包相关文章。\r\n</p>\r\n<p>\r\n\t通常使用的中间件的“栈”可以被作为数组（<code>递归应用</code>）传入，如此可以被混合并能匹配更复杂的功能。\r\n</p>\r\n<pre>var a = [middleware1, middleware2]\r\n  , b = [middleware3, middleware4]\r\n  , all = [a, b];\n\napp.get('/foo', a, function(){});\r\napp.get('/bar', a, function(){});\n\napp.get('/', a, middleware3, middleware4, function(){});\r\napp.get('/', a, b, function(){});\r\napp.get('/', all, function(){});\r\n</pre>\r\n<p>\r\n\t可以去express源码仓库查看完整的<a href=\"http://github.com/visionmedia/express/blob/master/examples/route-middleware/app.js\" target=\"_blank\">路由中间件示例</a>。\r\n</p>","create_date":"2012-04-01T05:38:36.545Z","diff":0,"down_num":0,"favorite_num":0,"favorites":[],"info":"  这里路径映射也可以理解为路由的意思，路由通过传入一个或多个附加的回调函数（或数组）到方法中，从而可以利用特定路由的中间件。该功能对限制访问以及加载路由使用的数据非常有用。     通常情况下异步数据的查询看起来像下面的样子，这里我们使用 :id 参数，并尝试获取一个用户。   [代码]   为了保持代码整洁并且提高可读性，我们可以在中间件内部应用该逻辑。正如你所看到的，将逻辑抽象到中间件里让我 ","last_modify_date":"2012-04-01T05:38:36.545Z","review_num":1,"title":"路由中间件","up_num":0,"ups":[],"user":{"_id":"4f3f4d9469cd2e1f78000001","avatar":"http://s1.csser.com/b6dd557640afdf49d0959f419678bda0-25.png","domain":"xianlihua","username":"一回"},"dateTime":1333258716545,"dateText":"2012-04-01 13:38","imdowner":false,"imfavoriter":false},{"_id":"4f77ea1cbe3baa0d7800153c","board":"4f77e6f996ca600f78000936","content":"<p>\r\n\t在CSSer前面的文章中我们已经接触过<code>app.get()</code>多次了，同时Express也提供了对其它HTTP动作的封装，如<code>app.post()</code>, <code>app.del()</code>等。\r\n</p>\r\n<p>\r\n\t对于<code>POST</code>最常见的例子，就是当我们提交一个表单时，下面我们在HTML中将表单的method特性设置为“post”，然后需要在服务端定义对该表单提交的路由控制。\r\n</p>\r\n<pre> &lt;form method=\"post\" action=\"/\"&gt;\r\n   &lt;input type=\"text\" name=\"user[name]\" /&gt;\r\n   &lt;input type=\"text\" name=\"user[email]\" /&gt;\r\n   &lt;input type=\"submit\" value=\"Submit\" /&gt;\r\n&lt;/form&gt;\r\n</pre>\r\n<p>\r\n\t默认情况下Express并不知道该如何处理该请求体，因此我们需要增加bodyParser中间件，用于分析<code>application/x-www-form-urlencoded</code>和<code>application/json</code>请求体，并把变量存入<code>req.body</code>。我们可以像下面的样子来“使用”中间件：\r\n</p>\r\n<pre>app.use(express.bodyParser());\r\n</pre>\r\n<p>\r\n\t接下来下面的路由就可以访问<code>req.body.user</code>对象了，该对象包含客户端提交的<code>name</code>和<code>email</code>属性。\r\n</p>\r\n<pre>app.post('/', function(req, res){\r\n  console.log(req.body.user);\r\n  res.redirect('back');\r\n});\r\n</pre>\r\n<p>\r\n\t要在表单中使用<code>PUT</code>的HTTP方法，我们可以利用名为<code>_method</code>的隐藏表单域，它能改变HTTP方法。而在服务端，我们首先需要利用<code>methodOverride</code>中间件，把它放在<code>bodyParser</code>中间件下方，从而可以利用包含表单值的<code>req.body</code>。\r\n</p>\r\n<pre>app.use(express.bodyParser());\r\napp.use(express.methodOverride());\r\n</pre>\r\n<p>\r\n\t之所以需要这样做，是因为这些处理并不总是默认进行的，原因很简单，因为这些对Express的整体功能来说并不是必需的，依据应用的具体需求，你并不一定需要这些功能，如果客户端直接支持<code>PUT</code>和<code>DELETE</code>方法也可以被直接访问到，同时<code>methodOverride</code>为表单提供了强大的解决方案，下面我们展示下PUT的使用：\r\n</p>\r\n<pre>&lt;form method=\"post\" action=\"/\"&gt;\r\n    &lt;input type=\"hidden\" name=\"_method\" value=\"put\" /&gt;\r\n    &lt;input type=\"text\" name=\"user[name]\" /&gt;\r\n    &lt;input type=\"text\" name=\"user[email]\" /&gt;\r\n    &lt;input type=\"submit\" value=\"Submit\" /&gt;\r\n&lt;/form&gt;\n\napp.put('/', function(){\r\n    console.log(req.body.user);\r\n    res.redirect('back');\r\n});\r\n</pre>","create_date":"2012-04-01T05:39:40.313Z","diff":0,"down_num":0,"favorite_num":0,"favorites":[],"info":"  在CSSer前面的文章中我们已经接触过 app.get() 多次了，同时Express也提供了对其它HTTP动作的封装，如 app.post() ,  app.del() 等。     对于 POST 最常见的例子，就是当我们提交一个表单时，下面我们在HTML中将表单的method特性设置为“post”，然后需要在服务端定义对该表单提交的路由控制。   [代码]   默认情况下Express并 ","last_modify_date":"2012-04-01T05:39:40.313Z","review_num":4,"title":"HTTP 方法","up_num":0,"ups":[],"user":{"_id":"4f3f4d9469cd2e1f78000001","avatar":"http://s1.csser.com/b6dd557640afdf49d0959f419678bda0-25.png","domain":"xianlihua","username":"一回"},"dateTime":1333258780313,"dateText":"2012-04-01 13:39","imdowner":false,"imfavoriter":false},{"content":"<p>\r\n\tExpress提供了<code>app.error()</code>方法来接收路由或传入<code>next(err)</code>的异常，下面的示例为不同的页面提供专门的<code>NotFound</code>异常服务：\r\n</p>\r\n<pre>function NotFound(msg){\r\n  this.name = 'NotFound in csser.com';\r\n  Error.call(this, msg);\r\n  Error.captureStackTrace(this, arguments.callee);\r\n}\n\nNotFound.prototype.__proto__ = Error.prototype;\n\napp.get('/404', function(req, res){\r\n  throw new NotFound;\r\n});\n\napp.get('/500', function(req, res){\r\n  throw new Error('keyboard cat!');\r\n});\r\n</pre>\r\n<p>\r\n\t像下面一样，我们可以多次调用<code>app.error()</code>，这里我们检查如果是<code>NotFound</code>实例就显示404页面，否则将其传入下一个错误处理。\r\n</p>\r\n<p>\r\n\t注意这些处理可以定义在任何地方，它们可以放在路由可以<code>listen()</code>之处。这也允许在<code>configure()</code>块内做定义，于是我们就可以以不同的基于环境的方式处理异常。\r\n</p>\r\n<pre>app.error(function(err, req, res, next){\r\n    if (err instanceof NotFound) {\r\n        res.render('404.jade');\r\n    } else {\r\n        next(err);\r\n    }\r\n});\r\n</pre>\r\n<p>\r\n\t下面的演示我们假设所有错误都为500错误，但你可以根据喜好选择。例如当node在处理文件系统调用时，就有可能接收到这样的错误对象，其<code>ENOENT</code>的<code>error.code</code>为“no such file or directory”，这时我们可以在错误处理函数中进行处理然后显示特定的页面给用户。\r\n</p>\r\n<pre>app.error(function(err, req, res){\r\n   res.render('500.jade', { error: err });\r\n});\r\n</pre>\r\n<p>\r\n\t我们的应用也可以利用Connect <code>errorHandler</code>中间件来汇报异常信息。例如我们想在“开发”环境输出异常到<code>stderr</code>：\r\n</p>\r\n<pre>app.use(express.errorHandler({ dumpExceptions: true }));\r\n</pre>\r\n<p>\r\n\t同时在开发期间我们想用好看的HTML页面显示异常信息时，可以设置<code>showStack</code>的值为true：\r\n</p>\r\n<pre>app.use(express.errorHandler({ showStack: true, dumpExceptions: true }));\r\n</pre>\r\n<p>\r\n\t如果请求头<code>Accept: application/json</code>，<code>errorHandler</code>中间件也能以<code>json</code>方式做出响应，这对依赖于客户端Javascript的应用开发很有益处。\r\n</p>","info":"  Express提供了 app.error() 方法来接收路由或传入 next(err) 的异常，下面的示例为不同的页面提供专门的 NotFound 异常服务：   [代码]   像下面一样，我们可以多次调用 app.error() ，这里我们检查如果是 NotFound 实例就显示404页面，否则将其传入下一个错误处理。     注意这些处理可以定义在任何地方，它们可以放在路由可以 liste ","user":{"_id":"4f3f4d9469cd2e1f78000001","avatar":"http://s1.csser.com/b6dd557640afdf49d0959f419678bda0-25.png","domain":"xianlihua","username":"一回"},"title":"错误处理","board":"4f77e6f996ca600f78000936","_id":"4f77ea4996ca600f78000a1f","diff":0,"down_num":0,"ups":[],"up_num":0,"favorites":[],"favorite_num":0,"review_num":0,"last_modify_date":"2012-04-01T05:40:25.624Z","create_date":"2012-04-01T05:40:25.624Z","dateTime":1333258825624,"dateText":"2012-04-01 13:40","imdowner":false,"imfavoriter":false},{"_id":"4f77ea6bbe3baa0d78001559","board":"4f77e6f996ca600f78000936","content":"<p>\r\n\t路由参数预处理通过隐式的数据处理，可以大幅提高应用代码的可读性和请求URL的验证。假如你经常性的从几个路由获取通用数据，如通过<code>/user/:id</code>加载用户信息，通常我们可能会这样做：\r\n</p>\r\n<pre>app.get('/user/:userId', function(req, res, next){\r\n  User.get(req.params.userId, function(err, user){\r\n    if (err) return next(err);\r\n    res.send('user ' + user.name);\r\n  });\r\n});\r\n</pre>\r\n<p>\r\n\t利用预处理后参数可以被映射到回调函数，从而可以提供诸如验证、强制性改变值，甚至从数据库中加载数据等功能。下面我们将调用<code>app.param()</code>并传入我们希望映射到某个中间件的参数，可以看到我们接收了包含占位符（:userId）值的<code>id</code>参数。在这里可以与平常一样进行用户数据加载以及错误处理，并能简单的通过调用<code>next()</code>将控制权转向下一个预处理或路由（路径控制）。\r\n</p>\r\n<pre>app.param('userId', function(req, res, next, id){\r\n  User.get(id, function(err, user){\r\n    if (err) return next(err);\r\n    if (!user) return next(new Error('failed to find user'));\r\n    req.user = user;\r\n    next();\r\n  });\r\n});\r\n</pre>\r\n<p>\r\n\t这样做，不仅向上面提到的可以大幅提高路由的可读性，还能在整个应用中共享该部分的逻辑实现，达到复用目的。\r\n</p>\r\n<pre>app.get('/user/:userId', function(req, res){\r\n  res.send('CSSer用户为 ' + req.user.name);\r\n});\r\n</pre>\r\n<p>\r\n\t对于简单的情况如路由占位符验证和强迫改变值，只需要传入1个参数（支持1个参数），期间抛出的异常将自动传入<code>next(err)</code>。\r\n</p>\r\n<pre>app.param('number', function(n){ return parseInt(n, 10); });\r\n</pre>\r\n<p>\r\n\t也可以同时将回调函数应用到多个占位符，比如路由<code>/commits/:from-:to</code>来说，:from和:to都是数值类型，我们可以将它们定义为数组：\r\n</p>\r\n<pre>app.param(['from', 'to'], function(n){ return parseInt(n, 10); });\r\n</pre>","create_date":"2012-04-01T05:40:59.993Z","diff":0,"down_num":0,"favorite_num":0,"favorites":[],"info":"  路由参数预处理通过隐式的数据处理，可以大幅提高应用代码的可读性和请求URL的验证。假如你经常性的从几个路由获取通用数据，如通过 /user/:id 加载用户信息，通常我们可能会这样做：   [代码]   利用预处理后参数可以被映射到回调函数，从而可以提供诸如验证、强制性改变值，甚至从数据库中加载数据等功能。下面我们将调用 app.param() 并传入我们希望映射到某个中间件的参数，可以看到我 ","last_modify_date":"2012-04-01T05:40:59.993Z","review_num":2,"title":"路由参数预处理","up_num":0,"ups":[],"user":{"_id":"4f3f4d9469cd2e1f78000001","avatar":"http://s1.csser.com/b6dd557640afdf49d0959f419678bda0-25.png","domain":"xianlihua","username":"一回"},"dateTime":1333258859993,"dateText":"2012-04-01 13:40","imdowner":false,"imfavoriter":false},{"_id":"4f77ea9596ca600f78000a3a","board":"4f77e6f996ca600f78000936","content":"<p>\r\n\t视图的文件名默认需遵循“&lt;name&gt;.&lt;engine&gt;”的形式，这里&lt;engine&gt;是要被加载的模块的名字。比如视图<code>layout.ejs</code>就是在告诉视图系统要<code>require(\"ejs\")</code>，被加载的模块必须输出<code>exports.compile(str, options)</code>方法，并要返回一个函数来遵守Express的模板接口约定。我们也可以使用<code>app.register()</code>来映射模板引擎到其它文件扩展名，从而实现更灵活的模板引擎行为，如此一来就可以实现“csser.html”可以被ejs引擎所渲染。\r\n</p>\r\n<p>\r\n\t下面我们将用<a href=\"http://github.com/visionmedia/jade\" target=\"_blank\">Jade</a>引擎来渲染<code>index.html</code>，因为我们没有设置<code>layout:false</code>，<code>index.jade</code>渲染后的内容将被作为<code>body</code>本地变量传入<code>layout.jade</code>。\r\n</p>\r\n<pre>app.get('/', function(req, res){\r\n    res.render('index.jade', { title: 'CSSer, 关注Web前端技术！' });\r\n});\r\n</pre>\r\n<p>\r\n\t新增的<code>view engine</code>设置可以指定默认模板引擎，如果我们想使用jade可以这样设置：\r\n</p>\r\n<pre>app.set('view engine', 'jade');\r\n</pre>\r\n<p>\r\n\t于是我们就可以通过下面的方式：\r\n</p>\r\n<pre>res.render('index');\r\n</pre>\r\n<p>\r\n\t代替如下方式:\r\n</p>\r\n<pre>res.render('index.jade');\r\n</pre>\r\n<p>\r\n\t当<code>view engine</code>设置后，模板的扩展名就成了可选项，同时我们还可以混合匹配多模板引擎：\r\n</p>\r\n<pre>res.render('another-page.ejs');\r\n</pre>\r\n<p>\r\n\tExpress同时提供了视图选项(<code>view options</code>)设置，这些设置会在每次视图渲染后应用，比如你并不经常使用layouts，就可以这样设置：\r\n</p>\r\n<pre>app.set('view options', {\r\n    layout: false\r\n});\r\n</pre>\r\n<p>\r\n\t如果需要，这些设置可以在后续的<code>res.render()</code>调用中被覆盖：\r\n</p>\r\n<pre>res.render('csser-view.ejs', { layout: true });\r\n</pre>\r\n<p>\r\n\t可以通过指定一个路径的方式来实现用自己的layout来代替系统默认的，比如如果我们将“<code>view engine</code>”设置为<code>jade</code>并且自定义了一个名为“<code>./views/mylayout.jade</code>”的layout，我们可以这样使用它：\r\n</p>\r\n<pre>res.render('page', { layout: 'mylayout' });\r\n</pre>\r\n<p>\r\n\t否则必须指定扩展名：\r\n</p>\r\n<pre>res.render('page', { layout: 'mylayout.jade' });\r\n</pre>\r\n<p>\r\n\t这些路径也可以是绝对路径：\r\n</p>\r\n<pre>res.render('page', { layout: __dirname + '/../../mylayout.jade' });\r\n</pre>\r\n<p>\r\n\t这方面较好的例子就是自定义<code>ejs</code>模板的开始和关闭的标记：\r\n</p>\r\n<pre>app.set('view options', {\r\n    open: '{{',\r\n    close: '}}'\r\n});\r\n</pre>","create_date":"2012-04-01T05:41:41.343Z","diff":0,"down_num":0,"favorite_num":0,"favorites":[],"info":"  视图的文件名默认需遵循“&lt;name&gt;.&lt;engine&gt;”的形式，这里&lt;engine&gt;是要被加载的模块的名字。比如视图 layout.ejs 就是在告诉视图系统要 require(\"ejs\") ，被加载的模块必须输出 exports.compile(str, options) 方法，并要返回一个函数来遵守Express的模板接口约定。我们也可以使用 app.r ","last_modify_date":"2012-04-01T05:41:41.343Z","review_num":2,"title":"视图渲染","up_num":0,"ups":[],"user":{"_id":"4f3f4d9469cd2e1f78000001","avatar":"http://s1.csser.com/b6dd557640afdf49d0959f419678bda0-25.png","domain":"xianlihua","username":"一回"},"dateTime":1333258901343,"dateText":"2012-04-01 13:41","imdowner":false,"imfavoriter":false},{"content":"<p>\r\n\tExpress视图系统原生支持局部和集合视图，这称作微型视图，主要用于渲染一个文档片段。比如与其在视图中循环显示评论，不如使用局部集合（partial collection）：\r\n</p>\r\n<pre>partial('comment', { collection: comments });\r\n</pre>\r\n<p>\r\n\t如果不需要其它选项或本地变量，我们可以省略对象而简单的传入评论数组，这和上面的示例是一样的：\r\n</p>\r\n<pre>partial('comment', comments);\r\n</pre>\r\n<p>\r\n\t当使用局部集合时，支持一些“魔术”本地变量：\r\n</p>\r\n<ul>\r\n\t<li>\r\n\t\t<code>firstInCollection</code> 当为第一个对象时该值为true\r\n\t</li>\r\n\t<li>\r\n\t\t<code>indexInCollection</code> 集合中对象的索引值\r\n\t</li>\r\n\t<li>\r\n\t\t<code>lastInCollection</code> 当为最后一个对象时为true\r\n\t</li>\r\n\t<li>\r\n\t\t<code>collectionLength</code> 集合的长度\r\n\t</li>\r\n</ul>\r\n<p>\r\n\t传入（或生成）的本地变量优先，但传入父视图的本地变量在子视图仍有效。因此如果我们用<code>partial(‘blog/post’, post)</code>来渲染博客日志时，将生成<code>post</code>的本地变量，但调用本函数的视图拥有本地<code>用户</code>，它在<code>blog/post</code>视图依然有效。\r\n</p>\r\n<p>\r\n\t性能提示：当使用局部集合渲染100长度的数组就意味着需要渲染100次视图，对于简单的集合你可以将循环内联，而不要使用局部集合，这样可以减少系统开销。\r\n</p>","info":"  Express视图系统原生支持局部和集合视图，这称作微型视图，主要用于渲染一个文档片段。比如与其在视图中循环显示评论，不如使用局部集合（partial collection）：   [代码]   如果不需要其它选项或本地变量，我们可以省略对象而简单的传入评论数组，这和上面的示例是一样的：   [代码]   当使用局部集合时，支持一些“魔术”本地变量：        firstInCollect ","user":{"_id":"4f3f4d9469cd2e1f78000001","avatar":"http://s1.csser.com/b6dd557640afdf49d0959f419678bda0-25.png","domain":"xianlihua","username":"一回"},"title":"局部视图","board":"4f77e6f996ca600f78000936","_id":"4f77eabbbe3baa0d780015a2","diff":0,"down_num":0,"ups":[],"up_num":0,"favorites":[],"favorite_num":0,"review_num":0,"last_modify_date":"2012-04-01T05:42:19.336Z","create_date":"2012-04-01T05:42:19.336Z","dateTime":1333258939336,"dateText":"2012-04-01 13:42","imdowner":false,"imfavoriter":false},{"content":"<p>\r\n\t视图查找是相对于父视图进行的，比如我们有一个名为“<code>views/user/list.jade</code>”的页面视图，如果在该视图中调用<code>partial(‘edit’)</code>，视图系统将会尝试查找并加载“<code>views/user/edit.jade</code>”，而<code>partial(‘../messages’)</code>将加载“<code>views/messages.jade</code>”。\r\n</p>\r\n<p>\r\n\t视图系统还支持索引模板，这样你就可以使用一个同名的目录。比如，在一个路由中我们执行<code>res.render(‘users’)</code>，这将指向“<code>views/users.jade</code>”或者“<code>views/users/index.jade</code>”。\r\n</p>\r\n<p>\r\n\t当使用上面的索引视图时，我们可以通过<code>partial(‘users’)</code>从同名目录下引用“<code>views/users/index.jade</code>”，同时视图系统会尝试“<code>../users/index</code>”，这能减少我们调用<code>partial(‘index’)</code>的需要。\r\n</p>","info":"  视图查找是相对于父视图进行的，比如我们有一个名为“ views/user/list.jade ”的页面视图，如果在该视图中调用 partial(‘edit’) ，视图系统将会尝试查找并加载“ views/user/edit.jade ”，而 partial(‘../messages’) 将加载“ views/messages.jade ”。     视图系统还支持索引模板，这样你就可以使用一个 ","user":{"_id":"4f3f4d9469cd2e1f78000001","avatar":"http://s1.csser.com/b6dd557640afdf49d0959f419678bda0-25.png","domain":"xianlihua","username":"一回"},"title":"视图查找","board":"4f77e6f996ca600f78000936","_id":"4f77eadabe3baa0d780015bd","diff":0,"down_num":0,"ups":[],"up_num":0,"favorites":[],"favorite_num":0,"review_num":0,"last_modify_date":"2012-04-01T05:42:50.758Z","create_date":"2012-04-01T05:42:50.758Z","dateTime":1333258970758,"dateText":"2012-04-01 13:42","imdowner":false,"imfavoriter":false},{"content":"<p>\r\n\tExpress支持许多模板引擎，常用的有：\r\n</p>\r\n<ul>\r\n\t<li>\r\n\t\t<a href=\"http://github.com/visionmedia/haml.js\" target=\"_blank\">Haml</a> haml 的实现\r\n\t</li>\r\n\t<li>\r\n\t\t<a href=\"http://jade-lang.com\" target=\"_blank\">Jade</a> haml.js 接替者，同时也是Express的默认模板引擎\r\n\t</li>\r\n\t<li>\r\n\t\t<a href=\"http://github.com/visionmedia/ejs\" target=\"_blank\">EJS</a> 嵌入JavaScript模板\r\n\t</li>\r\n\t<li>\r\n\t\t<a href=\"http://github.com/mauricemach/coffeekup\" target=\"_blank\">CoffeeKup</a> 基于CoffeeScript的模板引擎\r\n\t</li>\r\n\t<li>\r\n\t\t<a href=\"https://github.com/kof/node-jqtpl\" target=\"_blank\">jQuery Templates</a> 的NodeJS版本\r\n\t</li>\r\n</ul>","info":"  Express支持许多模板引擎，常用的有：        Haml  haml 的实现      Jade  haml.js 接替者，同时也是Express的默认模板引擎      EJS  嵌入JavaScript模板      CoffeeKup  基于CoffeeScript的模板引擎      jQuery Templates  的NodeJS版本     ","user":{"_id":"4f3f4d9469cd2e1f78000001","avatar":"http://s1.csser.com/b6dd557640afdf49d0959f419678bda0-25.png","domain":"xianlihua","username":"一回"},"title":"模板引擎","board":"4f77e6f996ca600f78000936","_id":"4f77eaffbe3baa0d780015d9","diff":0,"down_num":0,"ups":[],"up_num":0,"favorites":[],"favorite_num":0,"review_num":0,"last_modify_date":"2012-04-01T05:43:27.575Z","create_date":"2012-04-01T05:43:27.575Z","dateTime":1333259007575,"dateText":"2012-04-01 13:43","imdowner":false,"imfavoriter":false},{"_id":"4f77eb2cbe3baa0d780015f4","board":"4f77e6f996ca600f78000936","content":"<p>\r\n\t可以在Express中通过增加Connect的<code>session</code>中间件来开启Session支持，当然前提是需要在这之前使用<code>cookieParser</code>中间件，用于分析和处理<code>req.cookies</code>的cookie数据(我们知道session会利用cookie进行通信保持的)。\r\n</p>\r\n<pre>app.use(express.cookieParser());\r\napp.use(express.session({ secret: \"keyboard cat\" }));\r\n</pre>\r\n<p>\r\n\t默认<code>session</code>中间件使用Connect绑定的内存存储，但也有另外的实现方式。比如<a href=\"http://github.com/visionmedia/connect-redis\" target=\"_blank\">connect-redis</a>就提供了一个<a href=\"http://code.google.com/p/redis/\" target=\"_blank\">Redis</a>的session存储方案：\r\n</p>\r\n<pre>var RedisStore = require('connect-redis');\r\napp.use(express.cookieParser());\r\napp.use(express.session({ secret: \"CSSer加密字符串\", store: new RedisStore }));\r\n</pre>\r\n<p>\r\n\t现在<code>req.session</code>和<code>req.sessionStore</code>属性就可以被所有路由及下级中间件所访问，<code>req.session</code>的属性会伴随着每一次响应发送给客户端，下面是一个购物车的例子：\r\n</p>\r\n<pre>var RedisStore = require('connect-redis');\r\napp.use(express.bodyParser());\r\napp.use(express.cookieParser());\r\napp.use(express.session({ secret: \"keyboard cat\", store: new RedisStore }));\n\napp.post('/add-to-cart', function(req, res){\r\n  // 利用bodyParser()中间件处理POST提交的表单数据\r\n  var items = req.body.items;\r\n  req.session.items = items;\r\n  res.redirect('back');\r\n});\n\napp.get('/add-to-cart', function(req, res){\r\n  // 当页面回到返回并通过GET请求/add-to-cart 时\r\n  // 我们可以检查req.session.items &amp;&amp; req.session.items.length，然后将信息打印到页面\r\n  if (req.session.items &amp;&amp; req.session.items.length) {\r\n    req.flash('info', 'You have %s items in your cart', req.session.items.length);\r\n  }\r\n  res.render('shopping-cart');\r\n});\r\n</pre>\r\n<p>\r\n\t<code>req.session</code>对象还拥有许多其它方法，如<code>Session#touch()</code>, <code>Session#destroy()</code>, <code>Session#regenerate()</code>等用于session处理，更多信息请查看<a href=\"http://senchalabs.github.com/connect/middleware-session.html\" target=\"_blank\">Connect Session文档</a>。\r\n</p>","create_date":"2012-04-01T05:44:12.621Z","diff":0,"down_num":0,"favorite_num":0,"favorites":[],"info":"  可以在Express中通过增加Connect的 session 中间件来开启Session支持，当然前提是需要在这之前使用 cookieParser 中间件，用于分析和处理 req.cookies 的cookie数据(我们知道session会利用cookie进行通信保持的)。   [代码]   默认 session 中间件使用Connect绑定的内存存储，但也有另外的实现方式。比如 conne ","last_modify_date":"2012-04-01T05:44:12.622Z","review_num":14,"title":"Session Support","up_num":0,"ups":[],"user":{"_id":"4f3f4d9469cd2e1f78000001","avatar":"http://s1.csser.com/b6dd557640afdf49d0959f419678bda0-25.png","domain":"xianlihua","username":"一回"},"dateTime":1333259052621,"dateText":"2012-04-01 13:44","imdowner":false,"imfavoriter":false}], SORT = 'create_date', MODULES = ['app/board/show'];</script></div><div class="container"><a id="to-top" href="javascript:;">返回顶部</a><footer>©2011-2012 csser.com</footer></div><script>;(function(m, o, d, u, l, a, r) {if(m[d]) return;function f(n, t) { return function() { r.push(n, arguments); return t; } }m[d] = a = { args: (r = []), config: f(0, a), use: f(1, a) };m.define = f(2);u = o.createElement('script');u.id = d + 'node';u.src = 'http://s0.csser.com/sea.js?v0.5.1-3';l = o.getElementsByTagName('head')[0];l.insertBefore(u, l.firstChild);})(window, document, 'seajs');seajs.use('init.js?v0.5.1-3');</script><script id="more-boards-template" type="text/template">{{#boards}}
<li>
 <div class="post{{#hasPost}} has-post{{/hasPost}}">
  <strong title="{{post_num}}贴">{{post_num}}</strong>
 </div>
 <div class="info">
  <h3><a href="/board/{{_id}}" title="{{title}}">{{title}}</a></h3>
  {{#posts}}{{#postTitle}}
  <h4>&#187; <a href="/board/{{pid}}#/post/{{postId}}" title="{{postTitle}}">{{postTitle}}</a></h4>
  {{/postTitle}}{{/posts}}
 </div>
 <div class="cmd">
  <a class="btn btn-mini btn-inverse do-follow" href="javascript:;" data-type="board" data-id="{{_id}}" data-cmd="{{#imfollower}}unfollow{{/imfollower}}{{^imfollower}}follow{{/imfollower}}">{{#imfollower}}取消关注{{/imfollower}}{{^imfollower}}关注{{/imfollower}}</a>
  <span class="badge badge-warning">{{follow_num}}</span>
 </div>
</li>
{{/boards}}</script><script id="review-item-template" type="text/template"><a href="/user/{{user.domain}}" class="photo" title="{{user.username}}">
 <img src="{{user.avatar}}" width="25" height="25" alt="{{user.username}}" />
</a>
<div class="info">
 <a href="/user/{{user.domain}}" title="{{user.username}}">{{user.username}}</a>
 <span class="date" data-time="{{dateTime}}">{{dateText}}</span>
 {{^my}}<a href="javascript:;" class="reply" data-form="#form-%-{{#answer}}{{answer}}{{/answer}}{{^answer}}{{post}}{{/answer}}" data-username="{{user.username}} ">回复</a>{{/my}}
 {{#my}}<a class="edit-review" href="javascript:;">修改评论</a>{{/my}}
 <div class="review-content">{{{review}}}</div>
 {{#my}}
 <form method="post" class="form" id="form-{{#answer}}qreview{{/answer}}{{^answer}}breview{{/answer}}-{{_id}}" action="/{{#answer}}qreview{{/answer}}{{^answer}}breview{{/answer}}">
  <input type="hidden" name="_id" value="{{_id}}">
  <div class="control-group">
   <div class="controls"><textarea class="edit-review textarea" name="review" id="review"></textarea></div>
  </div>
  <div class="form-actions">
   <input type="submit" name="dosubmit" value="保存评论" class="btn btn-primary">
   <a href="javascript:;" class="btn edit-cancel">取消</a>
  </div>
 </form>
 {{/my}}
</div>
</script><div class="form-follow"></div><div class="show-info"></div><script>var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-94078-3']);
_gaq.push(['_trackPageview']);
(function() {
 var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
 ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
 var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script></body></html>